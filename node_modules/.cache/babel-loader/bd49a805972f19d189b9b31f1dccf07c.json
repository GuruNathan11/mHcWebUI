{"ast":null,"code":"'use strict';\n\nvar property = require('nested-property');\nvar keyBy = require('lodash.keyby');\nfunction createTree(array, rootNodes, customID, childrenProperty) {\n  var tree = [];\n  for (var rootNode in rootNodes) {\n    var node = rootNodes[rootNode];\n    var childNode = array[node[customID]];\n    if (!node && !rootNodes.hasOwnProperty(rootNode)) {\n      continue;\n    }\n    if (childNode) {\n      node[childrenProperty] = createTree(array, childNode, customID, childrenProperty);\n    }\n    tree.push(node);\n  }\n  return tree;\n}\nfunction groupByParents(array, options) {\n  var arrayByID = keyBy(array, options.customID);\n  return array.reduce(function (prev, item) {\n    var parentID = property.get(item, options.parentProperty);\n    if (!parentID || !arrayByID.hasOwnProperty(parentID)) {\n      parentID = options.rootID;\n    }\n    if (parentID && prev.hasOwnProperty(parentID)) {\n      prev[parentID].push(item);\n      return prev;\n    }\n    prev[parentID] = [item];\n    return prev;\n  }, {});\n}\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\nfunction deepClone(data) {\n  if (Array.isArray(data)) {\n    return data.map(deepClone);\n  } else if (isObject(data)) {\n    return Object.keys(data).reduce(function (o, k) {\n      o[k] = deepClone(data[k]);\n      return o;\n    }, {});\n  } else {\n    return data;\n  }\n}\n\n/**\n * arrayToTree\n * Convert a plain array of nodes (with pointers to parent nodes) to a nested\n * data structure\n *\n * @name arrayToTree\n * @function\n *\n * @param {Array} data An array of data\n * @param {Object} options An object containing the following fields:\n *\n *  - `parentProperty` (String): A name of a property where a link to\n * a parent node could be found. Default: 'parent_id'\n *  - `customID` (String): An unique node identifier. Default: 'id'\n *  - `childrenProperty` (String): A name of a property where children nodes\n * are going to be stored. Default: 'children'.\n *\n * @return {Array} Result of transformation\n */\n\nmodule.exports = function arrayToTree(data, options) {\n  options = Object.assign({\n    parentProperty: 'parent_id',\n    childrenProperty: 'children',\n    customID: 'id',\n    rootID: '0'\n  }, options);\n  if (!Array.isArray(data)) {\n    throw new TypeError('Expected an array but got an invalid argument');\n  }\n  var grouped = groupByParents(deepClone(data), options);\n  return createTree(grouped, grouped[options.rootID], options.customID, options.childrenProperty);\n};","map":{"version":3,"names":["property","require","keyBy","createTree","array","rootNodes","customID","childrenProperty","tree","rootNode","node","childNode","hasOwnProperty","push","groupByParents","options","arrayByID","reduce","prev","item","parentID","get","parentProperty","rootID","isObject","o","Object","prototype","toString","call","deepClone","data","Array","isArray","map","keys","k","module","exports","arrayToTree","assign","TypeError","grouped"],"sources":["E:/react/WebUI_MH/node_modules/array-to-tree/index.js"],"sourcesContent":["'use strict';\nvar property = require('nested-property');\nvar keyBy = require('lodash.keyby');\n\nfunction createTree(array, rootNodes, customID, childrenProperty) {\n  var tree = [];\n\n  for (var rootNode in rootNodes) {\n    var node = rootNodes[rootNode];\n    var childNode = array[node[customID]];\n\n    if (!node && !rootNodes.hasOwnProperty(rootNode)) {\n      continue;\n    }\n\n    if (childNode) {\n      node[childrenProperty] = createTree(\n        array,\n        childNode,\n        customID,\n        childrenProperty\n      );\n    }\n\n    tree.push(node);\n  }\n\n  return tree;\n}\n\nfunction groupByParents(array, options) {\n  var arrayByID = keyBy(array, options.customID);\n\n  return array.reduce(function(prev, item) {\n    var parentID = property.get(item, options.parentProperty);\n    if (!parentID || !arrayByID.hasOwnProperty(parentID)) {\n      parentID = options.rootID;\n    }\n\n    if (parentID && prev.hasOwnProperty(parentID)) {\n      prev[parentID].push(item);\n      return prev;\n    }\n\n    prev[parentID] = [item];\n    return prev;\n  }, {});\n}\n\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction deepClone(data) {\n  if (Array.isArray(data)) {\n    return data.map(deepClone);\n  } else if (isObject(data)) {\n    return Object.keys(data).reduce(function(o, k) {\n      o[k] = deepClone(data[k]);\n      return o;\n    }, {});\n  } else {\n    return data;\n  }\n}\n\n/**\n * arrayToTree\n * Convert a plain array of nodes (with pointers to parent nodes) to a nested\n * data structure\n *\n * @name arrayToTree\n * @function\n *\n * @param {Array} data An array of data\n * @param {Object} options An object containing the following fields:\n *\n *  - `parentProperty` (String): A name of a property where a link to\n * a parent node could be found. Default: 'parent_id'\n *  - `customID` (String): An unique node identifier. Default: 'id'\n *  - `childrenProperty` (String): A name of a property where children nodes\n * are going to be stored. Default: 'children'.\n *\n * @return {Array} Result of transformation\n */\n\nmodule.exports = function arrayToTree(data, options) {\n  options = Object.assign(\n    {\n      parentProperty: 'parent_id',\n      childrenProperty: 'children',\n      customID: 'id',\n      rootID: '0'\n    },\n    options\n  );\n\n  if (!Array.isArray(data)) {\n    throw new TypeError('Expected an array but got an invalid argument');\n  }\n\n  var grouped = groupByParents(deepClone(data), options);\n  return createTree(\n    grouped,\n    grouped[options.rootID],\n    options.customID,\n    options.childrenProperty\n  );\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}