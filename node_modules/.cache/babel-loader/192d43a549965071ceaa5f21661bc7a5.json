{"ast":null,"code":"import e from \"@babel/runtime/helpers/classCallCheck\";\nimport t from \"@babel/runtime/helpers/createClass\";\nimport n from \"@babel/runtime/helpers/assertThisInitialized\";\nimport r from \"@babel/runtime/helpers/inherits\";\nimport i from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport s from \"@babel/runtime/helpers/getPrototypeOf\";\nimport { Component as a, useRef as o, useEffect as u, useMemo as c } from \"react\";\nimport l from \"prop-types\";\nimport d from \"@babel/runtime/helpers/asyncToGenerator\";\nimport h from \"@babel/runtime/helpers/slicedToArray\";\nimport m from \"@babel/runtime/regenerator\";\nimport p from \"@babel/runtime/helpers/typeof\";\nvar f = \"object\" === (\"undefined\" == typeof window || \"undefined\" == typeof window ? \"undefined\" : p(window)),\n  v = f ? document : {},\n  g = [\"mousemove\", \"keydown\", \"wheel\", \"DOMMouseScroll\", \"mousewheel\", \"mousedown\", \"touchstart\", \"touchmove\", \"MSPointerDown\", \"MSPointerMove\", \"visibilitychange\"];\nfunction b(e, t) {\n  var n;\n  function r() {\n    for (var r = arguments.length, i = new Array(r), s = 0; s < r; s++) i[s] = arguments[s];\n    n && clearTimeout(n), n = setTimeout(function () {\n      e.apply(void 0, i), n = null;\n    }, t);\n  }\n  return r.cancel = function () {\n    clearTimeout(n);\n  }, r;\n}\nfunction T(e, t) {\n  var n = 0;\n  return function () {\n    var r = new Date().getTime();\n    if (!(r - n < t)) return n = r, e.apply(void 0, arguments);\n  };\n}\nvar _ = 0,\n  y = 0;\nfunction w() {\n  var e = new Date().getTime();\n  return e === _ ? 1e3 * e + ++y : (_ = e, y = 0, 1e3 * e);\n}\nfunction k() {\n  return Math.random().toString(36).substring(2);\n}\nfunction A() {\n  var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;\n  return new Promise(function (t) {\n    return setTimeout(t, e);\n  });\n}\nfunction I() {\n  return new Date().getTime();\n}\nvar E = {\n    create: function (e) {\n      var t = {\n        messagesCallback: null,\n        bc: new BroadcastChannel(e)\n      };\n      return t.bc.onmessage = function (e) {\n        t.messagesCallback && t.messagesCallback(e.data);\n      }, t;\n    },\n    close: function (e) {\n      e.bc.close();\n    },\n    onMessage: function (e, t) {\n      e.messagesCallback = t;\n    },\n    postMessage: function (e, t) {\n      try {\n        return e.bc.postMessage(t, !1), Promise.resolve();\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    },\n    canBeUsed: function () {\n      return \"function\" == typeof BroadcastChannel;\n    },\n    type: \"broadcastChannel\",\n    averageResponseTime: function () {\n      return 150;\n    },\n    microSeconds: w\n  },\n  L = function () {\n    function n() {\n      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 6e4;\n      e(this, n), this.ttl = t, this.set = new Set(), this.timeMap = new Map();\n    }\n    return t(n, [{\n      key: \"has\",\n      value: function (e) {\n        return this.set.has(e);\n      }\n    }, {\n      key: \"add\",\n      value: function (e) {\n        this.timeMap.set(e, I()), this.set.add(e), this._removeTooOldValues();\n      }\n    }, {\n      key: \"clear\",\n      value: function () {\n        this.set.clear(), this.timeMap.clear();\n      }\n    }, {\n      key: \"_removeTooOldValues\",\n      value: function () {\n        for (var e = I() - this.ttl, t = this.set[Symbol.iterator]();;) {\n          var n = t.next().value;\n          if (!n) return;\n          if (!(this.timeMap.get(n) < e)) return;\n          this.timeMap.delete(n), this.set.delete(n);\n        }\n      }\n    }]), n;\n  }();\nfunction O() {\n  var e;\n  if (\"undefined\" == typeof window) return null;\n  try {\n    e = window.localStorage, e = window[\"ie8-eventlistener/storage\"] || window.localStorage;\n  } catch (e) {}\n  return e;\n}\nfunction M(e, t) {\n  var n = e,\n    r = function (e) {\n      e.key === n && t(JSON.parse(e.newValue));\n    };\n  return window.addEventListener(\"storage\", r), r;\n}\nfunction D() {\n  var e = O();\n  if (!e) return !1;\n  try {\n    var t = \"__check\";\n    e.setItem(t, \"works\"), e.removeItem(t);\n  } catch (e) {\n    return !1;\n  }\n  return !0;\n}\nvar S = {\n    create: function (e) {\n      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n      if (!D()) throw new Error(\"❌ localStorage cannot be used.\");\n      var n = k(),\n        r = new L(t.removeTimeout),\n        i = {\n          channelName: e,\n          uuid: n,\n          eMIs: r\n        };\n      return i.listener = M(e, function (e) {\n        i.messagesCallback && e.uuid !== n && e.token && !r.has(e.token) && (e.data.time && e.data.time < i.messagesCallbackTime || (r.add(e.token), i.messagesCallback(e.data)));\n      }), i;\n    },\n    close: function (e) {\n      var t;\n      t = e.listener, window.removeEventListener(\"storage\", t);\n    },\n    onMessage: function (e, t, n) {\n      e.messagesCallbackTime = n, e.messagesCallback = t;\n    },\n    postMessage: function (e, t) {\n      return new Promise(function (n) {\n        var r = e.channelName,\n          i = {\n            token: k(),\n            time: new Date().getTime(),\n            data: t,\n            uuid: e.uuid\n          },\n          s = JSON.stringify(i);\n        O().setItem(r, s);\n        var a = document.createEvent(\"Event\");\n        a.initEvent(\"storage\", !0, !0), a.key = r, a.newValue = s, window.dispatchEvent(a), n();\n      });\n    },\n    canBeUsed: D,\n    type: \"localStorage\",\n    averageResponseTime: function () {\n      var e = navigator.userAgent.toLowerCase();\n      return e.includes(\"safari\") && !e.includes(\"chrome\") ? 240 : 120;\n    },\n    microSeconds: w\n  },\n  P = new Set();\nvar C = {\n    create: function (e) {\n      var t = {\n        name: e,\n        messagesCallback: null\n      };\n      return P.add(t), t;\n    },\n    close: function (e) {\n      P.delete(e);\n    },\n    onMessage: function (e, t) {\n      e.messagesCallback = t;\n    },\n    postMessage: function (e, t) {\n      return new Promise(function (n) {\n        return setTimeout(function () {\n          Array.from(P).filter(function (t) {\n            return t.name === e.name;\n          }).filter(function (t) {\n            return t !== e;\n          }).filter(function (e) {\n            return !!e.messagesCallback;\n          }).forEach(function (e) {\n            return e.messagesCallback(t);\n          }), n();\n        }, 5);\n      });\n    },\n    canBeUsed: function () {\n      return !0;\n    },\n    type: \"simulate\",\n    averageResponseTime: function () {\n      return 5;\n    },\n    microSeconds: w\n  },\n  x = [E, S];\nfunction B() {\n  var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};\n  if (e.type) {\n    if (\"simulate\" === e.type) return C;\n    var t = x.find(function (t) {\n      return t.type === e.type;\n    });\n    if (t) return t;\n    throw new Error(\"❌ Method \".concat(e.type, \" is not supported.\"));\n  }\n  var n = x.find(function (e) {\n    return e.canBeUsed();\n  });\n  if (!n) throw new Error(\"❌ No method found \".concat(JSON.stringify(x.map(function (e) {\n    return e.type;\n  }))));\n  return n;\n}\nvar R = function () {\n  function n(t) {\n    var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n    e(this, n), this.name = t, this.options = r, this.method = B(this.options), this.closed = !1, this._isListening = !1, this._onMessageListener = null, this._addEventListeners = {\n      message: [],\n      internal: []\n    }, this._unSendMessagePromises = new Set(), this._beforeClose = [], this._preparePromises = null, j(this);\n  }\n  return t(n, [{\n    key: \"postMessage\",\n    value: function (e) {\n      if (this.closed) throw new Error(\"❌ Cannot post message after channel has closed\");\n      return N(this, \"message\", e);\n    }\n  }, {\n    key: \"postInternal\",\n    value: function (e) {\n      return N(this, \"internal\", e);\n    }\n  }, {\n    key: \"onmessage\",\n    get: function () {\n      return this._onMessageListener;\n    },\n    set: function (e) {\n      var t = {\n        time: this.method.microSeconds(),\n        fn: e\n      };\n      U(this, \"message\", this._onMessageListener), e && \"function\" == typeof e ? (this._onMessageListener = t, Y(this, \"message\", t)) : this._onMessageListener = null;\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function (e, t) {\n      Y(this, e, {\n        time: this.method.microSeconds(),\n        fn: t\n      });\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function (e, t) {\n      U(this, e, this._addEventListeners[e].find(function (e) {\n        return e.fn === t;\n      }));\n    }\n  }, {\n    key: \"close\",\n    value: function () {\n      var e = this;\n      if (!this.closed) {\n        this.closed = !0;\n        var t = this._preparePromises ? this._preparePromises : Promise.resolve();\n        return this._onMessageListener = null, this._addEventListeners.message = [], t.then(function () {\n          return Promise.all(Array.from(e._unSendMessagePromises));\n        }).then(function () {\n          return Promise.all(e._beforeClose.map(function (e) {\n            return e();\n          }));\n        }).then(function () {\n          return e.method.close(e._state);\n        });\n      }\n    }\n  }, {\n    key: \"type\",\n    get: function () {\n      return this.method.type;\n    }\n  }, {\n    key: \"isClosed\",\n    value: function () {\n      return this.closed;\n    }\n  }]), n;\n}();\nfunction N(e, t, n) {\n  var r = {\n    time: e.method.microSeconds(),\n    type: t,\n    data: n\n  };\n  return (e._preparePromises ? e._preparePromises : Promise.resolve()).then(function () {\n    var t = e.method.postMessage(e._state, r);\n    return e._unSendMessagePromises.add(t), t.catch().then(function () {\n      return e._unSendMessagePromises.delete(t);\n    }), t;\n  });\n}\nfunction j(e) {\n  var t,\n    n = e.method.create(e.name, e.options);\n  (t = n) && \"function\" == typeof t.then ? (e._preparePromises = n, n.then(function (t) {\n    e._state = t;\n  })) : e._state = n;\n}\nfunction X(e) {\n  return e._addEventListeners.message.length > 0 || e._addEventListeners.internal.length > 0;\n}\nfunction Y(e, t, n) {\n  e._addEventListeners[t].push(n), function (e) {\n    if (!e._isListening && X(e)) {\n      var t = function (t) {\n          e._addEventListeners[t.type].forEach(function (e) {\n            t.time >= e.time && e.fn(t.data);\n          });\n        },\n        n = e.method.microSeconds();\n      e._preparePromises ? e._preparePromises.then(function () {\n        e._isListening = !0, e.method.onMessage(e._state, t, n);\n      }) : (e._isListening = !0, e.method.onMessage(e._state, t, n));\n    }\n  }(e);\n}\nfunction U(e, t, n) {\n  e._addEventListeners[t] = e._addEventListeners[t].filter(function (e) {\n    return e !== n;\n  }), function (e) {\n    if (e._isListening && !X(e)) {\n      e._isListening = !1;\n      var t = e.method.microSeconds();\n      e.method.onMessage(e._state, null, t);\n    }\n  }(e);\n}\nvar F = function () {\n  function n(t, r) {\n    var i = this;\n    e(this, n), this._channel = t, this._options = r, this.isLeader = !1, this.isDead = !1, this.token = k(), this._isApplying = !1, this._reApply = !1, this._unloadFns = [], this._listeners = [], this._intervals = [], this._duplicateListeners = function () {}, this._duplicateCalled = !1, this._onBeforeDie = d(m.mark(function e() {\n      return m.wrap(function (e) {\n        for (;;) switch (e.prev = e.next) {\n          case 0:\n          case \"end\":\n            return e.stop();\n        }\n      }, e);\n    }));\n    var s = function () {\n      var e = d(m.mark(function e() {\n        return m.wrap(function (e) {\n          for (;;) switch (e.prev = e.next) {\n            case 0:\n              return e.abrupt(\"return\", i.die());\n            case 1:\n            case \"end\":\n              return e.stop();\n          }\n        }, e);\n      }));\n      return function () {\n        return e.apply(this, arguments);\n      };\n    }();\n    f && (window.addEventListener(\"beforeUnload\", s), window.addEventListener(\"unload\", s), this._unloadFns.push([\"beforeUnload\", s]), this._unloadFns.push([\"unload\", s]));\n  }\n  var r;\n  return t(n, [{\n    key: \"applyOnce\",\n    value: function () {\n      var e = this;\n      if (this.isLeader) return Promise.resolve(!1);\n      if (this.isDead) return Promise.resolve(!1);\n      if (this._isApplying) return this._reApply = !0, Promise.resolve(!1);\n      this._isApplying = !0;\n      var t = !1,\n        n = function (n) {\n          \"leader\" === n.context && n.token !== e.token && (\"apply\" === n.action && n.token > e.token && (t = !0), \"tell\" === n.action && (t = !0));\n        };\n      return this._channel.addEventListener(\"internal\", n), V(this, \"apply\").then(function () {\n        return A(e._options.responseTime);\n      }).then(function () {\n        return t ? Promise.reject(new Error()) : V(e, \"apply\");\n      }).then(function () {\n        return A(e._options.responseTime);\n      }).then(function () {\n        return t ? Promise.reject(new Error()) : V(e);\n      }).then(function () {\n        return function (e) {\n          e.isLeader = !0;\n          var t = function (t) {\n            \"leader\" === t.context && \"apply\" === t.action && V(e, \"tell\"), \"leader\" !== t.context || \"tell\" !== t.action || e._duplicateCalled || (e._duplicateCalled = !0, e._duplicateListeners(), V(e, \"tell\"));\n          };\n          return e._channel.addEventListener(\"internal\", t), e._listeners.push(t), V(e, \"tell\");\n        }(e);\n      }).then(function () {\n        return !0;\n      }).catch(function () {\n        return !1;\n      }).then(function (t) {\n        return e._channel.removeEventListener(\"internal\", n), e._isApplying = !1, !t && e._reApply ? (e._reApply = !1, e.applyOnce()) : t;\n      });\n    }\n  }, {\n    key: \"awaitLeadership\",\n    value: function () {\n      var e;\n      return this._awaitLeadershipPromise || (this._awaitLeadershipPromise = (e = this).isLeader ? Promise.resolve() : new Promise(function (t) {\n        var n = !1;\n        function r() {\n          n || (n = !0, clearInterval(i), e._channel.removeEventListener(\"internal\", s), t(!0));\n        }\n        e.applyOnce().then(function () {\n          e.isLeader && r();\n        });\n        var i = setInterval(function () {\n          e.applyOnce().then(function () {\n            e.isLeader && r();\n          });\n        }, e._options.fallbackInterval);\n        e._intervals.push(i);\n        var s = function (t) {\n          \"leader\" === t.context && \"death\" === t.action && e.applyOnce().then(function () {\n            e.isLeader && r();\n          });\n        };\n        e._channel.addEventListener(\"internal\", s), e._listeners.push(s);\n      })), this._awaitLeadershipPromise;\n    }\n  }, {\n    key: \"onDuplicate\",\n    get: function () {\n      return this._duplicateListeners;\n    },\n    set: function (e) {\n      this._duplicateListeners = e;\n    }\n  }, {\n    key: \"onBeforeDie\",\n    get: function () {\n      return this._onBeforeDie;\n    },\n    set: function (e) {\n      this._onBeforeDie = e;\n    }\n  }, {\n    key: \"die\",\n    value: (r = d(m.mark(function e() {\n      var t = this;\n      return m.wrap(function (e) {\n        for (;;) switch (e.prev = e.next) {\n          case 0:\n            if (!this.isDead) {\n              e.next = 2;\n              break;\n            }\n            return e.abrupt(\"return\");\n          case 2:\n            return this.isDead = !0, e.next = 5, this.onBeforeDie();\n          case 5:\n            return this._listeners.forEach(function (e) {\n              return t._channel.removeEventListener(\"internal\", e);\n            }), this._intervals.forEach(function (e) {\n              return clearInterval(e);\n            }), this._unloadFns.forEach(function (e) {\n              f && window.removeEventListener(e[0], e[1]);\n            }), e.abrupt(\"return\", V(this, \"death\"));\n          case 9:\n          case \"end\":\n            return e.stop();\n        }\n      }, e, this);\n    })), function () {\n      return r.apply(this, arguments);\n    })\n  }]), n;\n}();\nfunction V(e, t) {\n  var n = {\n    context: \"leader\",\n    action: t,\n    token: e.token\n  };\n  return e._channel.postInternal(n);\n}\nvar J = function (e) {\n  var t = e.type,\n    n = e.channelName,\n    r = e.fallbackInterval,\n    i = e.responseTime,\n    s = e.emitOnAllTabs,\n    a = e.callbacks,\n    o = e.start,\n    u = e.reset,\n    c = e.pause,\n    l = e.resume,\n    p = new R(n, {\n      type: t\n    }),\n    f = function (e, t) {\n      if (e._leaderElector) throw new Error(\"❌ MessageChannel already has a leader-elector\");\n      var n = new F(e, t);\n      return e._beforeClose.push(d(m.mark(function e() {\n        return m.wrap(function (e) {\n          for (;;) switch (e.prev = e.next) {\n            case 0:\n              return e.abrupt(\"return\", n.die());\n            case 1:\n            case \"end\":\n              return e.stop();\n          }\n        }, e);\n      }))), e._leaderElector = n, n;\n    }(p, {\n      fallbackInterval: r,\n      responseTime: i\n    }),\n    v = {};\n  v[f.token] = !1;\n  var g = !1,\n    b = !0,\n    T = function () {\n      return g;\n    };\n  f.awaitLeadership().then(function () {\n    g = !0;\n  }), p.addEventListener(\"message\", function (e) {\n    var t = h(e, 2),\n      n = t[0],\n      r = t[1];\n    switch (n) {\n      case \"register\":\n        v[r] = !1;\n        break;\n      case \"deregister\":\n        delete v[r];\n        break;\n      case \"idle\":\n        _(r);\n        break;\n      case \"active\":\n        y(r);\n        break;\n      case \"emitIdle\":\n        a.onIdle();\n        break;\n      case \"emitActive\":\n        a.onActive();\n        break;\n      case \"start\":\n        o(!0);\n        break;\n      case \"reset\":\n        u(!0);\n        break;\n      case \"pause\":\n        c(!0);\n        break;\n      case \"resume\":\n        l(!0);\n    }\n  });\n  var _ = function () {\n      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : f.token;\n      v[e] = !0;\n      var t = Object.values(v).every(function (e) {\n        return e;\n      });\n      !b && t && (b = !0, T() ? (a.onIdle(), s && w(\"emitIdle\")) : w(\"idle\"));\n    },\n    y = function () {\n      var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : f.token;\n      v[e] = !1;\n      var t = Object.values(v).some(function (e) {\n        return !e;\n      });\n      b && t && (b = !1, T() ? (a.onActive(), s && w(\"emitActive\")) : w(\"active\"));\n    };\n  f.onDuplicate = d(m.mark(function e() {\n    return m.wrap(function (e) {\n      for (;;) switch (e.prev = e.next) {\n        case 0:\n          return e.next = 2, f.die();\n        case 2:\n          return e.abrupt(\"return\", e.sent);\n        case 3:\n        case \"end\":\n          return e.stop();\n      }\n    }, e);\n  })), f.onBeforeDie = d(m.mark(function e() {\n    return m.wrap(function (e) {\n      for (;;) switch (e.prev = e.next) {\n        case 0:\n          return e.next = 2, w(\"deregister\");\n        case 2:\n          return e.abrupt(\"return\", e.sent);\n        case 3:\n        case \"end\":\n          return e.stop();\n      }\n    }, e);\n  }));\n  var w = function () {\n      var e = d(m.mark(function e(t) {\n        return m.wrap(function (e) {\n          for (;;) switch (e.prev = e.next) {\n            case 0:\n              return e.abrupt(\"return\", p.postMessage([t, f.token]));\n            case 1:\n            case \"end\":\n              return e.stop();\n          }\n        }, e);\n      }));\n      return function (t) {\n        return e.apply(this, arguments);\n      };\n    }(),\n    k = function () {\n      var e = d(m.mark(function e() {\n        return m.wrap(function (e) {\n          for (;;) switch (e.prev = e.next) {\n            case 0:\n              return e.next = 2, f.die();\n            case 2:\n              return e.next = 4, p.close();\n            case 4:\n            case \"end\":\n              return e.stop();\n          }\n        }, e);\n      }));\n      return function () {\n        return e.apply(this, arguments);\n      };\n    }();\n  return w(\"register\"), {\n    close: k,\n    send: w,\n    isLeader: T,\n    idle: _,\n    active: y,\n    isAllIdle: function () {\n      return b;\n    },\n    setAllIdle: function (e) {\n      b = e;\n    }\n  };\n};\nfunction z(e) {\n  var t = function () {\n    if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n    if (Reflect.construct.sham) return !1;\n    if (\"function\" == typeof Proxy) return !0;\n    try {\n      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n    } catch (e) {\n      return !1;\n    }\n  }();\n  return function () {\n    var n,\n      r = s(e);\n    if (t) {\n      var a = s(this).constructor;\n      n = Reflect.construct(r, arguments, a);\n    } else n = r.apply(this, arguments);\n    return i(this, n);\n  };\n}\nvar G = function (i) {\n  r(o, a);\n  var s = z(o);\n  function o(t) {\n    var r;\n    if (e(this, o), (r = s.call(this, t)).state = {\n      idle: !1,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      lastIdle: null,\n      idleTime: 0,\n      remaining: null,\n      pageX: null,\n      pageY: null\n    }, r.tId = null, r.eventsBound = !1, r.callbackRefs = {}, t.debounce > 0 && t.throttle > 0) throw new Error(\"onAction can either be throttled or debounced (not both)\");\n    return t.debounce > 0 ? r._onAction = b(t.onAction, t.debounce) : t.throttle > 0 ? r._onAction = T(t.onAction, t.throttle) : r._onAction = t.onAction, t.eventsThrottle > 0 ? r.handleEvent = T(r._handleEvent.bind(n(r)), t.eventsThrottle) : r.handleEvent = r._handleEvent.bind(n(r)), t.startOnMount && !t.startManually || (r.state.idle = !0), r._toggleIdleState = r._toggleIdleState.bind(n(r)), r.start = r.start.bind(n(r)), r.reset = r.reset.bind(n(r)), r.pause = r.pause.bind(n(r)), r.resume = r.resume.bind(n(r)), r.isIdle = r.isIdle.bind(n(r)), r.getRemainingTime = r.getRemainingTime.bind(n(r)), r.getElapsedTime = r.getElapsedTime.bind(n(r)), r.getLastActiveTime = r.getLastActiveTime.bind(n(r)), r.getLastIdleTime = r.getLastIdleTime.bind(n(r)), r.getTotalIdleTime = r.getTotalIdleTime.bind(n(r)), r.getTotalActiveTime = r.getTotalActiveTime.bind(n(r)), r;\n  }\n  return t(o, [{\n    key: \"componentDidMount\",\n    value: function () {\n      var e = this.props,\n        t = e.startOnMount,\n        n = e.startManually;\n      this._setupTabManager(), n || (t ? this.start() : this._bindEvents());\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function (e) {\n      e.debounce !== this.props.debounce && this.props.debounce > 0 ? (this._onAction.cancel && this._onAction.cancel(), this._onAction = b(this.props.onAction, this.props.debounce)) : e.throttle !== this.props.throttle && this.props.throttle > 0 ? (this._onAction.cancel && this._onAction.cancel(), this._onAction = T(this.props.onAction, this.props.throttle)) : (e.throttle && 0 === this.props.throttle || e.debounce && 0 === this.props.debounce) && (this._onAction.cancel && this._onAction.cancel(), this._onAction = this.props.onAction), e.eventsThrottle !== this.props.eventsThrottle && (this._unbindEvents(), this.handleEvent = T(this._handleEvent.bind(this), this.props.eventsThrottle), this._bindEvents()), e.timeout !== this.props.timeout && this.state.idle && this.reset(), e.onActive !== this.props.onActive && (this.callbackRefs.onActive = this.props.onActive), e.onIdle !== this.props.onIdle && (this.callbackRefs.onIdle = this.props.onIdle);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function () {\n      clearTimeout(this.tId), this._unbindEvents(!0), this._onAction.cancel && this._onAction.cancel(), this.manager && this.manager.close().catch(console.error);\n    }\n  }, {\n    key: \"render\",\n    value: function () {\n      return this.props.children || null;\n    }\n  }, {\n    key: \"_setupTabManager\",\n    value: function () {\n      var e = this.props,\n        t = e.crossTab,\n        n = e.onIdle,\n        r = e.onActive;\n      if (this.callbackRefs = {\n        onIdle: n,\n        onActive: r\n      }, t) {\n        var i = Object.assign({\n            channelName: \"idle-timer\",\n            fallbackInterval: 2e3,\n            responseTime: 100,\n            removeTimeout: 6e4,\n            emitOnAllTabs: !1\n          }, !0 === t ? {} : t),\n          s = i.type,\n          a = i.channelName,\n          o = i.fallbackInterval,\n          u = i.responseTime,\n          c = i.emitOnAllTabs;\n        this.manager = J({\n          type: s,\n          channelName: a,\n          fallbackInterval: o,\n          responseTime: u,\n          emitOnAllTabs: c,\n          callbacks: this.callbackRefs,\n          start: this.start,\n          reset: this.reset,\n          pause: this.pause,\n          resume: this.resume\n        });\n      }\n    }\n  }, {\n    key: \"_bindEvents\",\n    value: function () {\n      var e = this;\n      if (f) {\n        var t = this.props,\n          n = t.element,\n          r = t.events,\n          i = t.passive,\n          s = t.capture;\n        this.eventsBound || (r.forEach(function (t) {\n          n.addEventListener(t, e.handleEvent, {\n            capture: s,\n            passive: i\n          });\n        }), this.eventsBound = !0);\n      }\n    }\n  }, {\n    key: \"_unbindEvents\",\n    value: function () {\n      var e = this,\n        t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n      if (f) {\n        var n = this.props,\n          r = n.element,\n          i = n.events,\n          s = n.passive,\n          a = n.capture;\n        (this.eventsBound || t) && (i.forEach(function (t) {\n          r.removeEventListener(t, e.handleEvent, {\n            capture: a,\n            passive: s\n          });\n        }), this.eventsBound = !1);\n      }\n    }\n  }, {\n    key: \"_toggleIdleState\",\n    value: function (e) {\n      var t = this;\n      this.setState(function (e) {\n        return {\n          idle: !e.idle,\n          lastIdle: e.idle ? e.lastIdle : +new Date() - t.props.timeout,\n          idleTime: e.idle ? e.idleTime + +new Date() - e.lastIdle : e.idleTime\n        };\n      }, function () {\n        var n = t.props,\n          r = n.onActive,\n          i = n.onIdle,\n          s = n.stopOnIdle;\n        t.state.idle ? (s && (clearTimeout(t.tId), t.tId = null, t._unbindEvents()), t.manager ? t.manager.idle() : i(e)) : (t._bindEvents(), t.manager ? t.manager.active() : r(e));\n      });\n    }\n  }, {\n    key: \"_handleEvent\",\n    value: function (e) {\n      var t = this.state,\n        n = t.remaining,\n        r = t.pageX,\n        i = t.pageY,\n        s = t.idle,\n        a = this.props,\n        o = a.timeout,\n        u = a.stopOnIdle;\n      if (this._onAction(e), !n) {\n        if (\"mousemove\" === e.type) {\n          if (e.pageX === r && e.pageY === i) return;\n          if (void 0 === e.pageX && void 0 === e.pageY) return;\n          if (this.getElapsedTime() < 200) return;\n        }\n        clearTimeout(this.tId), this.tId = null;\n        var c = +new Date() - this.getLastActiveTime();\n        (s && !u || !s && c > o) && this._toggleIdleState(e), this.setState({\n          lastActive: +new Date(),\n          pageX: e.pageX,\n          pageY: e.pageY\n        }), s && u || (this.tId = setTimeout(this._toggleIdleState, o));\n      }\n    }\n  }, {\n    key: \"start\",\n    value: function () {\n      var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];\n      clearTimeout(this.tId), this.tId = null, this._bindEvents(), this.setState({\n        idle: !1,\n        oldDate: +new Date(),\n        lastActive: +new Date(),\n        remaining: null\n      }), this.manager && (this.manager.setAllIdle(!1), !e && this.props.crossTab.emitOnAllTabs && this.manager.send(\"start\"));\n      var t = this.props.timeout;\n      this.tId = setTimeout(this._toggleIdleState, t);\n    }\n  }, {\n    key: \"reset\",\n    value: function () {\n      var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n      clearTimeout(this.tId), this.tId = null, this._bindEvents(), this.state.idle && (this.manager ? this.manager.active() : this.props.onActive()), this.manager && (this.manager.setAllIdle(!1), !e && this.props.crossTab.emitOnAllTabs && this.manager.send(\"reset\")), this.setState({\n        idle: !1,\n        oldDate: +new Date(),\n        lastActive: +new Date(),\n        remaining: null\n      });\n      var t = this.props.timeout;\n      this.tId = setTimeout(this._toggleIdleState, t);\n    }\n  }, {\n    key: \"pause\",\n    value: function () {\n      var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],\n        t = this.state.remaining;\n      null === t && (this._unbindEvents(), clearTimeout(this.tId), this.tId = null, this.manager && !e && this.props.crossTab.emitOnAllTabs && this.manager.send(\"pause\"), this.setState({\n        remaining: this.getRemainingTime()\n      }));\n    }\n  }, {\n    key: \"resume\",\n    value: function () {\n      var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],\n        t = this.state,\n        n = t.remaining,\n        r = t.idle;\n      null !== n && (this._bindEvents(), this.manager && !e && this.props.crossTab.emitOnAllTabs && this.manager.send(\"resume\"), r || (this.tId = setTimeout(this._toggleIdleState, n), this.setState({\n        remaining: null,\n        lastActive: +new Date()\n      })));\n    }\n  }, {\n    key: \"getRemainingTime\",\n    value: function () {\n      var e = this.state,\n        t = e.remaining,\n        n = e.lastActive,\n        r = this.props.timeout;\n      if (null !== t) return t < 0 ? 0 : t;\n      var i = r - (+new Date() - n);\n      return i < 0 ? 0 : i;\n    }\n  }, {\n    key: \"getElapsedTime\",\n    value: function () {\n      var e = this.state.oldDate;\n      return +new Date() - e;\n    }\n  }, {\n    key: \"getLastIdleTime\",\n    value: function () {\n      return this.state.lastIdle;\n    }\n  }, {\n    key: \"getTotalIdleTime\",\n    value: function () {\n      var e = this.state,\n        t = e.idle,\n        n = e.lastIdle,\n        r = e.idleTime;\n      return t ? +new Date() - n + r : r;\n    }\n  }, {\n    key: \"getLastActiveTime\",\n    value: function () {\n      return this.state.lastActive;\n    }\n  }, {\n    key: \"getTotalActiveTime\",\n    value: function () {\n      return this.getElapsedTime() - this.getTotalIdleTime();\n    }\n  }, {\n    key: \"isIdle\",\n    value: function () {\n      return this.state.idle;\n    }\n  }, {\n    key: \"isLeader\",\n    value: function () {\n      return !this.manager || this.manager.isLeader();\n    }\n  }]), o;\n}();\nfunction W() {\n  var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n    t = e.timeout,\n    n = void 0 === t ? 12e5 : t,\n    r = e.element,\n    i = void 0 === r ? v : r,\n    s = e.events,\n    a = void 0 === s ? g : s,\n    l = e.onIdle,\n    h = void 0 === l ? function () {} : l,\n    p = e.onActive,\n    _ = void 0 === p ? function () {} : p,\n    y = e.onAction,\n    w = void 0 === y ? function () {} : y,\n    k = e.debounce,\n    A = void 0 === k ? 0 : k,\n    I = e.throttle,\n    E = void 0 === I ? 0 : I,\n    L = e.eventsThrottle,\n    O = void 0 === L ? 200 : L,\n    M = e.startOnMount,\n    D = void 0 === M || M,\n    S = e.startManually,\n    P = void 0 !== S && S,\n    C = e.stopOnIdle,\n    x = void 0 !== C && C,\n    B = e.capture,\n    R = void 0 === B || B,\n    N = e.passive,\n    j = void 0 === N || N,\n    X = e.crossTab,\n    Y = void 0 !== X && X,\n    U = o(!1),\n    F = o(!0),\n    V = o(+new Date()),\n    z = o(null),\n    G = o(null),\n    W = o(null),\n    q = o(null),\n    H = o(null),\n    K = o(null),\n    Q = o(0),\n    Z = o(!0),\n    $ = o(n),\n    ee = o(null);\n  Y && (!0 === Y && (Y = {}), Y = Object.assign({\n    channelName: \"idle-timer\",\n    fallbackInterval: 2e3,\n    responseTime: 100,\n    removeTimeout: 6e4,\n    emitOnAllTabs: !1\n  }, Y));\n  var te = o(h),\n    ne = o(_),\n    re = o(w);\n  u(function () {\n    te.current = h;\n  }, [h]), u(function () {\n    ne.current = _;\n  }, [_]), u(function () {\n    re.current = w;\n  }, [w]);\n  var ie = c(function () {\n      function e(e) {\n        re.current(e);\n      }\n      return e.cancel && e.cancel(), A > 0 ? b(e, A) : E > 0 ? T(e, E) : e;\n    }, [E, A]),\n    se = function (e) {\n      var t = !F.current;\n      F.current = t, t ? (x && (clearTimeout(q.current), q.current = null, ce()), K.current = +new Date() - $.current, ee.current ? ee.current.idle() : te.current(e)) : (Q.current += +new Date() - K.current, ue(), ee.current ? ee.current.active() : ne.current(e));\n    },\n    ae = function (e) {\n      if (ie(e), !z.current) {\n        if (\"mousemove\" === e.type) {\n          if (e.pageX === G && e.pageY === W) return;\n          if (void 0 === e.pageX && void 0 === e.pageY) return;\n          if (de() < 200) return;\n        }\n        clearTimeout(q.current), q.current = null;\n        var t = +new Date() - pe();\n        (F.current && !x || !F.current && t > $.current) && se(e), H.current = +new Date(), G.current = e.pageX, W.current = e.pageY, F.current || (q.current = setTimeout(se, $.current));\n      }\n    },\n    oe = o(ae),\n    ue = function () {\n      f && (U.current || (a.forEach(function (e) {\n        i.addEventListener(e, oe.current, {\n          capture: R,\n          passive: j\n        });\n      }), U.current = !0));\n    },\n    ce = function () {\n      var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n      f && (U.current || e) && (a.forEach(function (e) {\n        i.removeEventListener(e, oe.current, {\n          capture: R,\n          passive: j\n        });\n      }), U.current = !1);\n    },\n    le = function () {\n      if (null !== z.current) return z.current < 0 ? 0 : z.current;\n      var e = $.current - (+new Date() - H.current);\n      return e < 0 ? 0 : e;\n    },\n    de = function () {\n      return +new Date() - V.current;\n    },\n    he = function () {\n      return K.current;\n    },\n    me = function () {\n      return F.current ? +new Date() - K.current + Q.current : Q.current;\n    },\n    pe = function () {\n      return H.current;\n    },\n    fe = function () {\n      return de() - me();\n    },\n    ve = function () {\n      return F.current;\n    },\n    ge = function () {\n      return !ee.current || ee.current.isLeader();\n    },\n    be = function () {\n      var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n      clearTimeout(q.current), q.current = null, ue(), F.current = !1, V.current = +new Date(), H.current = +new Date(), z.current = null, ee.current && (ee.current.setAllIdle(!1), !e && Y.emitOnAllTabs && ee.current.send(\"start\")), q.current = setTimeout(se, $.current);\n    },\n    Te = function () {\n      var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n      clearTimeout(q.current), q.current = null, ue(), F.current && (ee.current ? ee.current.active() : ne.current()), F.current = !1, V.current = +new Date(), H.current = +new Date(), z.current = null, ee.current && (ee.current.setAllIdle(!1), !e && Y.emitOnAllTabs && ee.current.send(\"reset\")), q.current = setTimeout(se, $.current);\n    },\n    _e = function () {\n      var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n      null === z.current && (ce(), clearTimeout(q.current), q.current = null, z.current = le(), ee.current && !e && Y.emitOnAllTabs && ee.current.send(\"pause\"));\n    },\n    ye = function () {\n      var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n      null !== z.current && (ue(), F.current || (q.current = setTimeout(se, z.current), z.current = null, H.current = +new Date()), ee.current && !e && Y.emitOnAllTabs && ee.current.send(\"resume\"));\n    };\n  return u(function () {\n    if (A > 0 && E > 0) throw new Error(\"onAction can either be throttled or debounced (not both)\");\n    return Y && (ee.current = J({\n      type: Y.type,\n      channelName: Y.channelName,\n      fallbackInterval: Y.fallbackInterval,\n      responseTime: Y.responseTime,\n      emitOnAllTabs: Y.emitOnAllTabs,\n      callbacks: {\n        onIdle: te.current,\n        onActive: ne.current\n      },\n      start: be,\n      reset: Te,\n      pause: _e,\n      resume: ye\n    })), P ? d(m.mark(function e() {\n      return m.wrap(function (e) {\n        for (;;) switch (e.prev = e.next) {\n          case 0:\n            if (clearTimeout(q.current), ce(!0), !Y) {\n              e.next = 5;\n              break;\n            }\n            return e.next = 5, ee.current.close();\n          case 5:\n          case \"end\":\n            return e.stop();\n        }\n      }, e);\n    })) : (D ? be() : ue(), d(m.mark(function e() {\n      return m.wrap(function (e) {\n        for (;;) switch (e.prev = e.next) {\n          case 0:\n            if (clearTimeout(q.current), ce(!0), ie.cancel && ie.cancel(), !Y) {\n              e.next = 6;\n              break;\n            }\n            return e.next = 6, ee.current.close();\n          case 6:\n          case \"end\":\n            return e.stop();\n        }\n      }, e);\n    })));\n  }, []), u(function () {\n    var e = U.current;\n    e && ce(), oe.current = O > 0 ? T(ae, O) : ae, e && ue();\n  }, [O]), u(function () {\n    $.current = n, !Z.current && F.current && Te(), Z.current = !1;\n  }, [n]), {\n    isIdle: ve,\n    isLeader: ge,\n    start: be,\n    pause: _e,\n    reset: Te,\n    resume: ye,\n    getLastIdleTime: he,\n    getTotalIdleTime: me,\n    getLastActiveTime: pe,\n    getTotalActiveTime: fe,\n    getElapsedTime: de,\n    getRemainingTime: le\n  };\n}\nG.propTypes = {\n  timeout: l.number,\n  events: l.arrayOf(l.string),\n  onIdle: l.func,\n  onActive: l.func,\n  onAction: l.func,\n  debounce: l.number,\n  throttle: l.number,\n  eventsThrottle: l.number,\n  element: l.oneOfType([l.object, l.element]),\n  startOnMount: l.bool,\n  startManually: l.bool,\n  stopOnIdle: l.bool,\n  passive: l.bool,\n  capture: l.bool,\n  crossTab: l.oneOfType([l.bool, l.shape({\n    type: l.oneOf([\"broadcastChannel\", \"localStorage\", \"simulate\"]),\n    channelName: l.string,\n    fallbackInterval: l.number,\n    responseTime: l.number,\n    removeTimeout: l.number,\n    emitOnAllTabs: l.bool\n  })])\n}, G.defaultProps = {\n  timeout: 12e5,\n  element: v,\n  events: g,\n  onIdle: function () {},\n  onActive: function () {},\n  onAction: function () {},\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: !0,\n  startManually: !1,\n  stopOnIdle: !1,\n  capture: !0,\n  passive: !0,\n  crossTab: !1\n}, W.propTypes = {\n  timeout: l.number,\n  events: l.arrayOf(l.string),\n  onIdle: l.func,\n  onActive: l.func,\n  onAction: l.func,\n  debounce: l.number,\n  throttle: l.number,\n  eventsThrottle: l.number,\n  element: l.oneOfType([l.object, l.element]),\n  startOnMount: l.bool,\n  startManually: l.bool,\n  stopOnIdle: l.bool,\n  passive: l.bool,\n  capture: l.bool,\n  crossTab: l.oneOfType([l.bool, l.shape({\n    type: l.oneOf([\"broadcastChannel\", \"localStorage\", \"simulate\"]),\n    channelName: l.string,\n    fallbackInterval: l.number,\n    responseTime: l.number,\n    removeTimeout: l.number,\n    emitOnAllTabs: l.bool\n  })])\n}, W.defaultProps = {\n  timeout: 12e5,\n  element: v,\n  events: g,\n  onIdle: function () {},\n  onActive: function () {},\n  onAction: function () {},\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: !0,\n  startManually: !1,\n  stopOnIdle: !1,\n  capture: !0,\n  passive: !0,\n  crossTab: !1\n};\nexport default G;\nexport { W as useIdleTimer };","map":{"version":3,"names":["f","window","p","v","document","g","b","e","t","n","r","arguments","length","i","Array","s","clearTimeout","setTimeout","apply","cancel","T","Date","getTime","_","y","w","k","Math","random","toString","substring","A","Promise","I","E","create","messagesCallback","bc","BroadcastChannel","onmessage","data","close","onMessage","postMessage","resolve","reject","canBeUsed","type","averageResponseTime","microSeconds","L","ttl","set","Set","timeMap","Map","key","value","has","add","_removeTooOldValues","clear","Symbol","iterator","next","get","delete","O","localStorage","M","listener","JSON","parse","newValue","addEventListener","D","setItem","removeItem","S","Error","removeTimeout","channelName","uuid","eMIs","token","time","messagesCallbackTime","removeEventListener","stringify","a","createEvent","initEvent","dispatchEvent","navigator","userAgent","toLowerCase","includes","P","C","name","from","filter","forEach","x","B","find","concat","map","R","options","method","closed","_isListening","_onMessageListener","_addEventListeners","message","internal","_unSendMessagePromises","_beforeClose","_preparePromises","j","this","N","msg","fn","U","Y","then","all","_state","catch","X","push","listenerFn","F","_channel","_options","isLeader","isDead","_isApplying","_reApply","_unloadFns","_listeners","_intervals","_duplicateListeners","_duplicateCalled","_onBeforeDie","d","m","mark","wrap","prev","stop","abrupt","die","unloadFn","handleMessage","context","action","V","responseTime","isLeaderListener","applyOnce","success","_awaitLeadershipPromise","clearInterval","setInterval","fallbackInterval","whenDeathListener","onBeforeDie","postInternal","J","TabManager","emitOnAllTabs","callbacks","o","start","u","reset","c","pause","l","resume","_leaderElector","awaitLeadership","h","onIdle","onActive","idle","Object","values","every","active","some","onDuplicate","sent","send","isAllIdle","setAllIdle","z","Reflect","construct","sham","Proxy","Boolean","prototype","valueOf","call","constructor","G","state","oldDate","lastActive","lastIdle","idleTime","remaining","pageX","pageY","tId","eventsBound","callbackRefs","debounce","throttle","_onAction","onAction","eventsThrottle","handleEvent","_handleEvent","bind","startOnMount","startManually","_toggleIdleState","isIdle","getRemainingTime","getElapsedTime","getLastActiveTime","getLastIdleTime","getTotalIdleTime","getTotalActiveTime","props","_setupTabManager","_bindEvents","_unbindEvents","timeout","manager","console","error","children","crossTab","assign","element","events","passive","capture","setState","stopOnIdle","timeLeft","W","q","H","K","Q","Z","$","ee","te","ne","re","current","ie","se","ce","ue","ae","de","pe","oe","le","he","me","fe","ve","ge","be","Te","_e","ye","propTypes","number","arrayOf","string","func","oneOfType","object","bool","shape","oneOf","defaultProps","useIdleTimer"],"sources":["../src/utils.js","../src/MessageChannel/methods/broadcastChannel.js","../src/MessageChannel/ObliviousSet.js","../src/MessageChannel/methods/localStorage.js","../src/MessageChannel/methods/simulate.js","../src/MessageChannel/methodChooser.js","../src/MessageChannel/MessageChannel.js","../src/MessageChannel/leaderElection.js","../src/TabManager.js","../src/IdleTimer.js","../src/useIdleTimer.js"],"sourcesContent":["/**\n * Determine if we are in a browser\n * or a server environment\n * @type {Boolean}\n * @private\n */\nexport const IS_BROWSER =\n  (typeof window === 'undefined' ? 'undefined' : typeof window) === 'object'\n\n/**\n * Default element to listen for events on\n * @type {Object}\n * @private\n */\nexport const DEFAULT_ELEMENT = IS_BROWSER ? document : {}\n\n/**\n * The default events to determine activity\n * @type {Array}\n * @private\n */\nexport const DEFAULT_EVENTS = [\n  'mousemove',\n  'keydown',\n  'wheel',\n  'DOMMouseScroll',\n  'mousewheel',\n  'mousedown',\n  'touchstart',\n  'touchmove',\n  'MSPointerDown',\n  'MSPointerMove',\n  'visibilitychange'\n]\n\n/**\n * Creates a debounced function that delays invoking func until\n * after delay milliseconds has elapsed since the last time the\n * debounced function was invoked.\n * @name debounced\n * @param  {Function} fn   Function to debounce\n * @param  {Number} delay  How long to wait\n * @return {Function}      Executed Function\n * @private\n **/\nexport function debounced (fn, delay) {\n  let timerId\n  function result (...args) {\n    if (timerId) {\n      clearTimeout(timerId)\n    }\n    timerId = setTimeout(() => {\n      fn(...args)\n      timerId = null\n    }, delay)\n  }\n\n  result.cancel = function () {\n    clearTimeout(timerId)\n  }\n\n  return result\n}\n\n/**\n * Creates a throttled function that only invokes func at most\n * once per every wait milliseconds.\n * @name throttled\n * @param  {Function} fn   Function to debounce\n * @param  {Number} delay  How long to wait\n * @return {Function}      Executed Function\n * @private\n **/\nexport function throttled (fn, delay) {\n  let lastCall = 0\n  return function (...args) {\n    const now = new Date().getTime()\n    if (now - lastCall < delay) {\n      return\n    }\n    lastCall = now\n    return fn(...args)\n  }\n}\n\nlet lastMs = 0\nlet additional = 0\n\n/**\n * Returns current time in microseconds.\n *\n * @returns {Number} current time in microseconds\n * @private\n */\nexport function microSeconds () {\n  const ms = new Date().getTime()\n  if (ms === lastMs) {\n    additional++\n    return ms * 1000 + additional\n  } else {\n    lastMs = ms\n    additional = 0\n    return ms * 1000\n  }\n}\n\n/**\n * Generate and return a random token.\n *\n * @returns {String} Random token.\n * @private\n */\nexport function randomToken () {\n  return Math.random().toString(36).substring(2)\n}\n\n/**\n * Checks if a js object is a promise.\n *\n * @param {*} obj  Any javascript object.\n * @returns {Boolean} Wether or not this object is a promise.\n */\nexport function isPromise (obj) {\n  if (obj && typeof obj.then === 'function') {\n    /* istanbul ignore next */\n    return true\n  } else {\n    return false\n  }\n}\n\n/**\n * Sleeps for x amount of milliseconds.\n *\n * @param {Number} time   Amount of time in milliseconds.\n * @returns {Promise}\n * @private\n */\nexport function sleep (time = 0) {\n  return new Promise(resolve => setTimeout(resolve, time))\n}\n\n/**\n * Get the current timestamp.\n *\n * @returns {Number}\n * @private\n */\nexport function now () {\n  return new Date().getTime()\n}\n\n/**\n * Waits until the given function returns true\n * @param  {function}  fn\n * @return {Promise}\n */\nexport function waitUntil (fn, timeout = 0, interval = 20) {\n  let timedOut = false\n  let ok = false\n\n  /* istanbul ignore next */\n  if (timeout !== 0) {\n    sleep(timeout).then(() => {\n      timedOut = true\n    })\n  }\n\n  return new Promise((resolve, reject) => {\n    const runLoop = () => {\n      if (ok) {\n        resolve()\n        return\n      }\n      /* istanbul ignore next */\n      if (timedOut) {\n        reject(new Error(`❌ waitUntil reached timeout of ${timeout}ms`))\n        return\n      }\n      sleep(interval).then(() => {\n        ok = fn()\n        runLoop()\n      })\n    }\n    runLoop()\n  })\n}\n","/* eslint-env browser */\nimport { microSeconds } from '../../utils'\n\nexport const type = 'broadcastChannel'\n\nexport function create (channelName) {\n  const state = {\n    messagesCallback: null,\n    bc: new BroadcastChannel(channelName)\n  }\n\n  state.bc.onmessage = msg => {\n    if (state.messagesCallback) {\n      state.messagesCallback(msg.data)\n    }\n  }\n\n  return state\n}\n\nexport function close (channelState) {\n  channelState.bc.close()\n}\n\nexport function postMessage (channelState, messageJson) {\n  try {\n    channelState.bc.postMessage(messageJson, false)\n    return Promise.resolve()\n  } catch (err) {\n    /* istanbul ignore next */\n    return Promise.reject(err)\n  }\n}\n\nexport function onMessage (channelState, fn) {\n  channelState.messagesCallback = fn\n}\n\nexport function canBeUsed () {\n  if (typeof BroadcastChannel === 'function') {\n    return true\n  } else {\n    /* istanbul ignore next */\n    return false\n  }\n}\n\nexport function averageResponseTime () {\n  return 150\n}\n\nexport default {\n  create,\n  close,\n  onMessage,\n  postMessage,\n  canBeUsed,\n  type,\n  averageResponseTime,\n  microSeconds\n}\n","import { now } from '../utils'\n\nexport default class ObliviousSet {\n  constructor (ttl = 1000 * 60) {\n    this.ttl = ttl\n    this.set = new Set()\n    this.timeMap = new Map()\n  }\n\n  has (value) {\n    return this.set.has(value)\n  }\n\n  add (value) {\n    this.timeMap.set(value, now())\n    this.set.add(value)\n    this._removeTooOldValues()\n  }\n\n  clear () {\n    this.set.clear()\n    this.timeMap.clear()\n  }\n\n  _removeTooOldValues () {\n    const olderThen = now() - this.ttl\n    const iterator = this.set[Symbol.iterator]()\n\n    while (true) {\n      const value = iterator.next().value\n      if (!value) return // no more elements\n      const time = this.timeMap.get(value)\n      if (time < olderThen) {\n        this.timeMap.delete(value)\n        this.set.delete(value)\n      } else {\n        // We reached a value that is not old enough\n        return\n      }\n    }\n  }\n}\n","import ObliviousSet from '../ObliviousSet'\n\nimport {\n  randomToken,\n  microSeconds\n} from '../../utils'\n\nexport const type = 'localStorage'\n\n/**\n * Returns local storage instance\n */\nexport function getLocalStorage () {\n  let localStorage\n  if (typeof window === 'undefined') return null\n  try {\n    localStorage = window.localStorage\n    localStorage = window['ie8-eventlistener/storage'] || window.localStorage\n  } catch (e) {\n    // New versions of Firefox throw a Security exception\n    // if cookies are disabled. See\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1028153\n  }\n  return localStorage\n}\n\nexport function storageKey (channelName) {\n  return channelName\n}\n\n/**\n* writes the new message to the storage\n* and fires the storage-event so other readers can find it\n*/\nexport function postMessage (channelState, messageJson) {\n  return new Promise(resolve => {\n    const key = storageKey(channelState.channelName)\n    const writeObj = {\n      token: randomToken(),\n      time: new Date().getTime(),\n      data: messageJson,\n      uuid: channelState.uuid\n    }\n    const value = JSON.stringify(writeObj)\n    getLocalStorage().setItem(key, value)\n\n    /**\n       * StorageEvent does not fire the 'storage' event\n       * in the window that changes the state of the local storage.\n       * So we fire it manually\n       */\n    const ev = document.createEvent('Event')\n    ev.initEvent('storage', true, true)\n    ev.key = key\n    ev.newValue = value\n    window.dispatchEvent(ev)\n\n    resolve()\n  })\n}\n\nexport function addStorageEventListener (channelName, fn) {\n  const key = storageKey(channelName)\n  const listener = ev => {\n    if (ev.key === key) {\n      fn(JSON.parse(ev.newValue))\n    }\n  }\n  window.addEventListener('storage', listener)\n  return listener\n}\nexport function removeStorageEventListener (listener) {\n  window.removeEventListener('storage', listener)\n}\n\nexport function create (channelName, options = {}) {\n  if (!canBeUsed()) {\n    /* istanbul ignore next */\n    throw new Error('❌ localStorage cannot be used.')\n  }\n\n  const uuid = randomToken()\n\n  /**\n     * eMIs\n     * contains all messages that have been emitted before\n     * @type {ObliviousSet}\n     */\n  const eMIs = new ObliviousSet(options.removeTimeout)\n\n  const state = {\n    channelName,\n    uuid,\n    eMIs // emittedMessagesIds\n  }\n\n  state.listener = addStorageEventListener(\n    channelName,\n    (msgObj) => {\n      if (!state.messagesCallback) return // no listener\n      if (msgObj.uuid === uuid) return // own message\n      if (!msgObj.token || eMIs.has(msgObj.token)) return // already emitted\n      if (msgObj.data.time && msgObj.data.time < state.messagesCallbackTime) return // too old\n\n      eMIs.add(msgObj.token)\n      state.messagesCallback(msgObj.data)\n    }\n  )\n\n  return state\n}\n\nexport function close (channelState) {\n  removeStorageEventListener(channelState.listener)\n}\n\nexport function onMessage (channelState, fn, time) {\n  channelState.messagesCallbackTime = time\n  channelState.messagesCallback = fn\n}\n\nexport function canBeUsed () {\n  const ls = getLocalStorage()\n\n  if (!ls) return false\n\n  try {\n    const key = '__check'\n    ls.setItem(key, 'works')\n    ls.removeItem(key)\n  } catch (e) {\n    // Safari 10 in private mode will not allow write access to local\n    // storage and fail with a QuotaExceededError. See\n    // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API#Private_Browsing_Incognito_modes\n\n    /* istanbul ignore next */\n    return false\n  }\n\n  return true\n}\n\n/* istanbul ignore next */\nexport function averageResponseTime () {\n  const defaultTime = 120\n  const userAgent = navigator.userAgent.toLowerCase()\n  if (userAgent.includes('safari') && !userAgent.includes('chrome')) {\n    // safari is much slower so this time is higher\n    return defaultTime * 2\n  }\n  return defaultTime\n}\n\nexport default {\n  create,\n  close,\n  onMessage,\n  postMessage,\n  canBeUsed,\n  type,\n  averageResponseTime,\n  microSeconds\n}\n","import { microSeconds } from '../../utils'\n\nexport const type = 'simulate'\n\nconst SIMULATE_CHANNELS = new Set()\n\nexport function create (channelName) {\n  const state = {\n    name: channelName,\n    messagesCallback: null\n  }\n  SIMULATE_CHANNELS.add(state)\n\n  return state\n}\n\nexport function close (channelState) {\n  SIMULATE_CHANNELS.delete(channelState)\n}\n\nexport function postMessage (channelState, messageJson) {\n  return new Promise(resolve => setTimeout(() => {\n    const channelArray = Array.from(SIMULATE_CHANNELS)\n    channelArray\n      .filter(channel => channel.name === channelState.name)\n      .filter(channel => channel !== channelState)\n      .filter(channel => !!channel.messagesCallback)\n      .forEach(channel => channel.messagesCallback(messageJson))\n    resolve()\n  }, 5))\n}\n\nexport function onMessage (channelState, fn) {\n  channelState.messagesCallback = fn\n}\n\n/* istanbul ignore next */\nexport function canBeUsed () {\n  return true\n}\n\n/* istanbul ignore next */\nexport function averageResponseTime () {\n  return 5\n}\n\nexport default {\n  create,\n  close,\n  onMessage,\n  postMessage,\n  canBeUsed,\n  type,\n  averageResponseTime,\n  microSeconds\n}\n","import BroadcastChannelMethod from './methods/broadcastChannel'\nimport LocalStorageMethod from './methods/localStorage'\nimport SimulateMethod from './methods/simulate'\n\n// Order is important\nconst METHODS = [\n  BroadcastChannelMethod,\n  LocalStorageMethod\n]\n\nexport function chooseMethod (options = {}) {\n  if (options.type) {\n    // For testing\n    if (options.type === 'simulate') {\n      return SimulateMethod\n    }\n\n    // Chosen type\n    const method = METHODS.find(m => m.type === options.type)\n    if (!method) throw new Error(`❌ Method ${options.type} is not supported.`)\n    else return method\n  }\n\n  const useMethod = METHODS.find(method => method.canBeUsed())\n\n  /* istanbul ignore next */\n  if (!useMethod) {\n    throw new Error(`❌ No method found ${JSON.stringify(METHODS.map(m => m.type))}`)\n  }\n  return useMethod\n}\n","import { chooseMethod } from './methodChooser'\nimport { isPromise } from '../utils'\n\nexport class MessageChannel {\n  constructor (name, options = {}) {\n    this.name = name\n    this.options = options\n    this.method = chooseMethod(this.options)\n    this.closed = false\n\n    // isListening\n    this._isListening = false\n\n    /**\n     * _onMessageListener\n     * setting onmessage twice,\n     * will overwrite the first listener\n     */\n    this._onMessageListener = null\n\n    /**\n     * _addEventListeners\n     */\n    this._addEventListeners = {\n      message: [],\n      internal: []\n    }\n\n    /**\n     * Un send message promises\n     * where the sending is still in progress\n     * @type {Set<Promise>}\n     */\n    this._unSendMessagePromises = new Set()\n\n    /**\n     * _beforeClose\n     * array of promises that will be awaited\n     * before the channel is closed\n     */\n    this._beforeClose = []\n\n    /**\n     * _preparePromise\n     */\n    this._preparePromises = null\n    _prepareChannel(this)\n  }\n\n  postMessage (msg) {\n    if (this.closed) {\n      throw new Error(\n        '❌ Cannot post message after channel has closed'\n      )\n    }\n    return _post(this, 'message', msg)\n  }\n\n  postInternal (msg) {\n    return _post(this, 'internal', msg)\n  }\n\n  set onmessage (fn) {\n    const time = this.method.microSeconds()\n    const listenObj = {\n      time,\n      fn\n    }\n    _removeListenerObject(this, 'message', this._onMessageListener)\n    if (fn && typeof fn === 'function') {\n      this._onMessageListener = listenObj\n      _addListenerObject(this, 'message', listenObj)\n    } else {\n      /* istanbul ignore next */\n      this._onMessageListener = null\n    }\n  }\n\n  /* istanbul ignore next */\n  get onmessage () {\n    return this._onMessageListener\n  }\n\n  addEventListener (type, fn) {\n    const time = this.method.microSeconds()\n    const listenObj = {\n      time,\n      fn\n    }\n    _addListenerObject(this, type, listenObj)\n  }\n\n  removeEventListener (type, fn) {\n    const obj = this._addEventListeners[type].find(obj => obj.fn === fn)\n    _removeListenerObject(this, type, obj)\n  }\n\n  close () {\n    if (this.closed) {\n      return\n    }\n    this.closed = true\n    const awaitPrepare = this._preparePromises ? this._preparePromises : Promise.resolve()\n\n    this._onMessageListener = null\n    this._addEventListeners.message = []\n\n    return awaitPrepare\n      // Wait until all current sending are processed\n      .then(() => Promise.all(Array.from(this._unSendMessagePromises)))\n      // Run before-close hooks\n      .then(() => Promise.all(this._beforeClose.map(fn => fn())))\n      // Close the channel\n      .then(() => this.method.close(this._state))\n  }\n\n  get type () {\n    return this.method.type\n  }\n\n  isClosed () {\n    return this.closed\n  }\n}\n\nfunction _post (messageChannel, type, msg) {\n  const time = messageChannel.method.microSeconds()\n  const msgObj = {\n    time,\n    type,\n    data: msg\n  }\n\n  const awaitPrepare = messageChannel._preparePromises ? messageChannel._preparePromises : Promise.resolve()\n  return awaitPrepare.then(() => {\n    const sendPromise = messageChannel.method.postMessage(\n      messageChannel._state,\n      msgObj\n    )\n\n    // add/remove to un-send messages list\n    messageChannel._unSendMessagePromises.add(sendPromise)\n    sendPromise\n      .catch()\n      .then(() => messageChannel._unSendMessagePromises.delete(sendPromise))\n\n    return sendPromise\n  })\n}\n\nfunction _prepareChannel (channel) {\n  const maybePromise = channel.method.create(channel.name, channel.options)\n  /* istanbul ignore next */\n  if (isPromise(maybePromise)) {\n    channel._preparePromises = maybePromise\n    maybePromise.then(s => {\n      channel._state = s\n    })\n  } else {\n    channel._state = maybePromise\n  }\n}\n\nfunction _hasMessageListeners (channel) {\n  if (channel._addEventListeners.message.length > 0) return true\n  if (channel._addEventListeners.internal.length > 0) return true\n  return false\n}\n\nfunction _addListenerObject (channel, type, obj) {\n  channel._addEventListeners[type].push(obj)\n  _startListening(channel)\n}\n\nfunction _removeListenerObject (channel, type, obj) {\n  channel._addEventListeners[type] = channel._addEventListeners[type].filter(o => o !== obj)\n  _stopListening(channel)\n}\n\nfunction _startListening (channel) {\n  if (!channel._isListening && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n\n    const listenerFn = msgObj => {\n      channel._addEventListeners[msgObj.type].forEach(obj => {\n        if (msgObj.time >= obj.time) {\n          obj.fn(msgObj.data)\n        }\n      })\n    }\n\n    const time = channel.method.microSeconds()\n    if (channel._preparePromises) {\n      /* istanbul ignore next */\n      channel._preparePromises.then(() => {\n        channel._isListening = true\n        channel.method.onMessage(\n          channel._state,\n          listenerFn,\n          time\n        )\n      })\n    } else {\n      channel._isListening = true\n      channel.method.onMessage(\n        channel._state,\n        listenerFn,\n        time\n      )\n    }\n  }\n}\n\nfunction _stopListening (channel) {\n  if (channel._isListening && !_hasMessageListeners(channel)) {\n    // no one is listening, stop subscribing\n    channel._isListening = false\n    const time = channel.method.microSeconds()\n    channel.method.onMessage(\n      channel._state,\n      null,\n      time\n    )\n  }\n}\n","import { IS_BROWSER, sleep, randomToken } from '../utils'\n\nclass LeaderElection {\n  constructor (channel, options) {\n    this._channel = channel\n    this._options = options\n\n    this.isLeader = false\n    this.isDead = false\n    this.token = randomToken()\n\n    this._isApplying = false\n    this._reApply = false\n\n    // things to clean up\n    this._unloadFns = []\n    this._listeners = []\n    this._intervals = []\n    this._duplicateListeners = () => { }\n    this._duplicateCalled = false\n    this._onBeforeDie = async () => {}\n\n    const unloadFn = async () => this.die()\n\n    if (IS_BROWSER) {\n      window.addEventListener('beforeUnload', unloadFn)\n      window.addEventListener('unload', unloadFn)\n\n      this._unloadFns.push(['beforeUnload', unloadFn])\n      this._unloadFns.push(['unload', unloadFn])\n    }\n  }\n\n  applyOnce () {\n    if (this.isLeader) return Promise.resolve(false)\n    if (this.isDead) return Promise.resolve(false)\n\n    // do nothing if already running\n    if (this._isApplying) {\n      this._reApply = true\n      return Promise.resolve(false)\n    }\n    this._isApplying = true\n\n    let stopCriteria = false\n    const received = []\n\n    const handleMessage = (msg) => {\n      if (msg.context === 'leader' && msg.token !== this.token) {\n        received.push(msg)\n\n        if (msg.action === 'apply') {\n          // Other is applying\n          if (msg.token > this.token) {\n            // Other has higher token, stop applying\n            stopCriteria = true\n          }\n        }\n\n        if (msg.action === 'tell') {\n          // Other is already leader\n          stopCriteria = true\n        }\n      }\n    }\n    this._channel.addEventListener('internal', handleMessage)\n\n    return _sendMessage(this, 'apply') // send out that this one is applying\n      .then(() => sleep(this._options.responseTime)) // let others time to respond\n      .then(() => {\n        if (stopCriteria) return Promise.reject(new Error())\n        else return _sendMessage(this, 'apply')\n      })\n      .then(() => sleep(this._options.responseTime)) // let others time to respond\n      .then(() => {\n        if (stopCriteria) return Promise.reject(new Error())\n        else return _sendMessage(this)\n      })\n      .then(() => beLeader(this)) // no one disagreed -> this one is now leader\n      .then(() => true)\n      .catch(() => false) // apply not successful\n      .then(success => {\n        this._channel.removeEventListener('internal', handleMessage)\n        this._isApplying = false\n        if (!success && this._reApply) {\n          this._reApply = false\n          return this.applyOnce()\n        } else return success\n      })\n  }\n\n  awaitLeadership () {\n    if (\n      !this._awaitLeadershipPromise\n    ) {\n      this._awaitLeadershipPromise = _awaitLeadershipOnce(this)\n    }\n    return this._awaitLeadershipPromise\n  }\n\n  set onDuplicate (fn) {\n    this._duplicateListeners = fn\n  }\n\n  /* istanbul ignore next */\n  get onDuplicate () {\n    return this._duplicateListeners\n  }\n\n  set onBeforeDie (fn) {\n    this._onBeforeDie = fn\n  }\n\n  /* istanbul ignore next */\n  get onBeforeDie () {\n    return this._onBeforeDie\n  }\n\n  async die () {\n    if (this.isDead) return\n    this.isDead = true\n\n    await this.onBeforeDie()\n    this._listeners.forEach(listener => this._channel.removeEventListener('internal', listener))\n    this._intervals.forEach(interval => clearInterval(interval))\n    this._unloadFns.forEach(uFn => {\n      if (IS_BROWSER) {\n        window.removeEventListener(uFn[0], uFn[1])\n      }\n    })\n    return _sendMessage(this, 'death')\n  }\n}\n\nfunction _awaitLeadershipOnce (leaderElector) {\n  if (leaderElector.isLeader) return Promise.resolve()\n\n  return new Promise(resolve => {\n    let resolved = false\n\n    function finish () {\n      /* istanbul ignore next */\n      if (resolved) {\n        return\n      }\n      resolved = true\n      clearInterval(interval)\n      leaderElector._channel.removeEventListener('internal', whenDeathListener)\n      resolve(true)\n    }\n\n    // try once now\n    leaderElector.applyOnce().then(() => {\n      if (leaderElector.isLeader) {\n        finish()\n      }\n    })\n\n    // try on fallbackInterval\n    const interval = setInterval(() => {\n      /* istanbul ignore next */\n      leaderElector.applyOnce().then(() => {\n        if (leaderElector.isLeader) {\n          finish()\n        }\n      })\n    }, leaderElector._options.fallbackInterval)\n    leaderElector._intervals.push(interval)\n\n    // try when other leader dies\n    const whenDeathListener = msg => {\n      if (msg.context === 'leader' && msg.action === 'death') {\n        leaderElector.applyOnce().then(() => {\n          if (leaderElector.isLeader) finish()\n        })\n      }\n    }\n    leaderElector._channel.addEventListener('internal', whenDeathListener)\n    leaderElector._listeners.push(whenDeathListener)\n  })\n}\n\n/**\n * Sends and internal message over the broadcast-channel\n */\nfunction _sendMessage (leaderElector, action) {\n  const msgJson = {\n    context: 'leader',\n    action,\n    token: leaderElector.token\n  }\n  return leaderElector._channel.postInternal(msgJson)\n}\n\nexport function beLeader (leaderElector) {\n  leaderElector.isLeader = true\n\n  const isLeaderListener = msg => {\n    if (msg.context === 'leader' && msg.action === 'apply') {\n      _sendMessage(leaderElector, 'tell')\n    }\n\n    if (msg.context === 'leader' && msg.action === 'tell' && !leaderElector._duplicateCalled) {\n      /**\n       * Another instance is also leader!\n       * This can happen on rare events\n       * like when the CPU is at 100% for long time\n       * or the tabs are open very long and the browser throttles them.\n       */\n      leaderElector._duplicateCalled = true\n      leaderElector._duplicateListeners() // message the lib user so the app can handle the problem\n      _sendMessage(leaderElector, 'tell') // ensure other leader also knows the problem\n    }\n  }\n  leaderElector._channel.addEventListener('internal', isLeaderListener)\n  leaderElector._listeners.push(isLeaderListener)\n  return _sendMessage(leaderElector, 'tell')\n}\n\nexport function createLeaderElection (channel, options) {\n  if (channel._leaderElector) {\n    throw new Error('❌ MessageChannel already has a leader-elector')\n  }\n\n  const elector = new LeaderElection(channel, options)\n  channel._beforeClose.push(async () => elector.die())\n\n  channel._leaderElector = elector\n  return elector\n}\n","import { MessageChannel, createLeaderElection } from './MessageChannel'\nexport const TabManager = ({\n  type,\n  channelName,\n  fallbackInterval,\n  responseTime,\n  emitOnAllTabs,\n  callbacks,\n  start,\n  reset,\n  pause,\n  resume\n}) => {\n  const channel = new MessageChannel(channelName, { type })\n  const elector = createLeaderElection(channel, { fallbackInterval, responseTime })\n  const registry = {}\n\n  // Register self\n  registry[elector.token] = false\n\n  let leader = false\n  let allIdle = true\n\n  const isLeader = () => leader\n\n  elector.awaitLeadership().then(() => {\n    leader = true\n  })\n\n  channel.addEventListener('message', ([type, id]) => {\n    switch (type) {\n      case 'register':\n        registry[id] = false\n        break\n      case 'deregister':\n        delete registry[id]\n        break\n      case 'idle':\n        idle(id)\n        break\n      case 'active':\n        active(id)\n        break\n      case 'emitIdle':\n        callbacks.onIdle()\n        break\n      case 'emitActive':\n        callbacks.onActive()\n        break\n      case 'start':\n        start(true)\n        break\n      case 'reset':\n        reset(true)\n        break\n      case 'pause':\n        pause(true)\n        break\n      case 'resume':\n        resume(true)\n        break\n      default:\n        // no op\n    }\n  })\n\n  const setAllIdle = bool => {\n    allIdle = bool\n  }\n\n  const isAllIdle = () => allIdle\n\n  const idle = (id = elector.token) => {\n    registry[id] = true\n    const isIdle = Object.values(registry).every(v => v)\n    if (!allIdle && isIdle) {\n      allIdle = true\n      if (isLeader()) {\n        callbacks.onIdle()\n        if (emitOnAllTabs) send('emitIdle')\n      } else {\n        send('idle')\n      }\n    }\n  }\n\n  const active = (id = elector.token) => {\n    registry[id] = false\n    const isActive = Object.values(registry).some(v => !v)\n    if (allIdle && isActive) {\n      allIdle = false\n      if (isLeader()) {\n        callbacks.onActive()\n        if (emitOnAllTabs) send('emitActive')\n      } else {\n        send('active')\n      }\n    }\n  }\n\n  /* istanbul ignore next */\n  elector.onDuplicate = async () => await elector.die()\n  elector.onBeforeDie = async () => await send('deregister')\n\n  const send = async message => channel.postMessage([message, elector.token])\n\n  const close = async () => {\n    await elector.die()\n    await channel.close()\n  }\n\n  // Register self with remote tabs\n  send('register')\n\n  return { close, send, isLeader, idle, active, isAllIdle, setAllIdle }\n}\n","/**\n *  ___    _ _     _____ _\n * |_ _|__| | | __|_   _(_)_ __ ___   ___ _ __\n *  | |/ _` | |/ _ \\| | | | '_ ` _ \\ / _ \\ '__|\n *  | | (_| | |  __/| | | | | | | | |  __/ |\n * |___\\__,_|_|\\___||_| |_|_| |_| |_|\\___|_|\n *\n * @name IdleTimer\n * @author Randy Lebeau\n * @private\n */\n\nimport { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { TabManager } from './TabManager'\nimport { IS_BROWSER, DEFAULT_ELEMENT, DEFAULT_EVENTS, debounced, throttled } from './utils'\n\n/**\n * Detects when your user is idle\n * @class IdleTimer\n * @private\n */\nclass IdleTimer extends Component {\n  /**\n   * Creates an instance of IdleTimer\n   * bind all of our internal events here\n   * for best performance\n   * @param {Object} props\n   * @return {IdleTimer}\n   * @private\n   */\n  constructor (props) {\n    super(props)\n\n    /**\n     * Sets initial component state\n     * @type {Object}\n     * @private\n     */\n    this.state = {\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      lastIdle: null,\n      idleTime: 0,\n      remaining: null,\n      pageX: null,\n      pageY: null\n    }\n\n    /**\n     * The timer instance\n     * @type {Timeout}\n     * @private\n     */\n    this.tId = null\n\n    /**\n     * Wether or not events are bound\n     * @type {boolean}\n     * @private\n     */\n    this.eventsBound = false\n\n    this.callbackRefs = {}\n\n    // Debounce and throttle can't both be set\n    if (props.debounce > 0 && props.throttle > 0) {\n      throw new Error('onAction can either be throttled or debounced (not both)')\n    }\n\n    // Create debounced action if applicable\n    if (props.debounce > 0) {\n      this._onAction = debounced(props.onAction, props.debounce)\n\n    // Create throttled action if applicable\n    } else if (props.throttle > 0) {\n      this._onAction = throttled(props.onAction, props.throttle)\n\n    // Set custom onAction\n    } else {\n      this._onAction = props.onAction\n    }\n\n    // Create a throttle event handler if applicable\n    if (props.eventsThrottle > 0) {\n      this.handleEvent = throttled(this._handleEvent.bind(this), props.eventsThrottle)\n    } else {\n      this.handleEvent = this._handleEvent.bind(this)\n    }\n\n    // If startOnMount is set, idle state defaults to true\n    if (!props.startOnMount || props.startManually) {\n      this.state.idle = true\n    }\n\n    // Bind all events to component scope, built for speed 🚀\n    this._toggleIdleState = this._toggleIdleState.bind(this)\n    this.start = this.start.bind(this)\n    this.reset = this.reset.bind(this)\n    this.pause = this.pause.bind(this)\n    this.resume = this.resume.bind(this)\n    this.isIdle = this.isIdle.bind(this)\n    this.getRemainingTime = this.getRemainingTime.bind(this)\n    this.getElapsedTime = this.getElapsedTime.bind(this)\n    this.getLastActiveTime = this.getLastActiveTime.bind(this)\n    this.getLastIdleTime = this.getLastIdleTime.bind(this)\n    this.getTotalIdleTime = this.getTotalIdleTime.bind(this)\n    this.getTotalActiveTime = this.getTotalActiveTime.bind(this)\n  }\n\n  /**\n   * Runs once the component has mounted\n   * here we handle automatically starting\n   * the idletimer\n   * @private\n   */\n  componentDidMount () {\n    const { startOnMount, startManually } = this.props\n\n    // Set up cross tab\n    this._setupTabManager()\n\n    if (startManually) return\n    if (startOnMount) {\n      this.start()\n    } else {\n      this._bindEvents()\n    }\n  }\n\n  componentDidUpdate (prevProps) {\n    // Update debounce function\n    if ((prevProps.debounce !== this.props.debounce) && this.props.debounce > 0) {\n      if (this._onAction.cancel) this._onAction.cancel()\n      this._onAction = debounced(this.props.onAction, this.props.debounce)\n    } else\n    // Update throttle function\n    if ((prevProps.throttle !== this.props.throttle) && this.props.throttle > 0) {\n      if (this._onAction.cancel) this._onAction.cancel()\n      this._onAction = throttled(this.props.onAction, this.props.throttle)\n    } else\n    // Remove throttle or debounce\n    if (\n      (prevProps.throttle && this.props.throttle === 0) ||\n      (prevProps.debounce && this.props.debounce === 0)\n    ) {\n      if (this._onAction.cancel) this._onAction.cancel()\n      this._onAction = this.props.onAction\n    }\n\n    // Update event throttle function\n    if (prevProps.eventsThrottle !== this.props.eventsThrottle) {\n      this._unbindEvents()\n      this.handleEvent = throttled(this._handleEvent.bind(this), this.props.eventsThrottle)\n      this._bindEvents()\n    }\n    // Update timeout value\n    if (prevProps.timeout !== this.props.timeout) {\n      if (this.state.idle) this.reset()\n    }\n\n    // Update callback refs\n    if (prevProps.onActive !== this.props.onActive) this.callbackRefs.onActive = this.props.onActive\n    if (prevProps.onIdle !== this.props.onIdle) this.callbackRefs.onIdle = this.props.onIdle\n  }\n\n  /**\n   * Called before the component un-mounts\n   * here we clear the timer and remove\n   * all the event listeners\n   * @private\n   */\n  componentWillUnmount () {\n    // Clear timeout to prevent delayed state changes\n    clearTimeout(this.tId)\n    this._unbindEvents(true)\n    // Cancel any debounced onAction handlers\n    if (this._onAction.cancel) this._onAction.cancel()\n    /* istanbul ignore next */\n    if (this.manager) {\n      this.manager.close().catch(console.error)\n    }\n  }\n\n  /**\n   * Render children if IdleTimer is used as a wrapper\n   * @return {Component} children\n   * @private\n   */\n  render () {\n    const { children } = this.props\n    return children || null\n  }\n\n  /**\n   * Setup the Tab Manager.\n   * @private\n   */\n  _setupTabManager () {\n    const { crossTab, onIdle, onActive } = this.props\n    this.callbackRefs = { onIdle, onActive }\n\n    /* istanbul ignore next */\n    if (crossTab) {\n      const {\n        type,\n        channelName,\n        fallbackInterval,\n        responseTime,\n        emitOnAllTabs\n      } = Object.assign({\n        channelName: 'idle-timer',\n        fallbackInterval: 2000,\n        responseTime: 100,\n        removeTimeout: 1000 * 60,\n        emitOnAllTabs: false\n      }, crossTab === true ? {} : crossTab)\n\n      this.manager = TabManager({\n        type,\n        channelName,\n        fallbackInterval,\n        responseTime,\n        emitOnAllTabs,\n        callbacks: this.callbackRefs,\n        start: this.start,\n        reset: this.reset,\n        pause: this.pause,\n        resume: this.resume\n      })\n    }\n  }\n\n  /**\n   * Binds the specified events\n   * @private\n   */\n  _bindEvents () {\n    // Don't bind events if\n    // we are not in a browser\n    if (!IS_BROWSER) return\n    // Otherwise we bind all the events\n    // to the supplied element\n    const { element, events, passive, capture } = this.props\n    if (!this.eventsBound) {\n      events.forEach(e => {\n        element.addEventListener(e, this.handleEvent, {\n          capture,\n          passive\n        })\n      })\n      this.eventsBound = true\n    }\n  }\n\n  /**\n   * Unbinds all the bound events\n   * @private\n   */\n  _unbindEvents (force = false) {\n    // If we are not in a browser\n    // we don't need to unbind events\n    if (!IS_BROWSER) return\n    // Unbind all events\n    const { element, events, passive, capture } = this.props\n    if (this.eventsBound || force) {\n      events.forEach(e => {\n        element.removeEventListener(e, this.handleEvent, {\n          capture,\n          passive\n        })\n      })\n      this.eventsBound = false\n    }\n  }\n\n  /**\n   * Toggles the idle state and calls\n   * the correct action function\n   * @private\n   */\n  _toggleIdleState (e) {\n    // Fire the appropriate action\n    // and pass the event through\n    // Toggle the idle state\n    this.setState((prevState) => ({\n      idle: !prevState.idle,\n      lastIdle: !prevState.idle ? (+new Date()) - this.props.timeout : prevState.lastIdle,\n      idleTime: prevState.idle ? prevState.idleTime + (+new Date()) - prevState.lastIdle : prevState.idleTime\n    }), () => {\n      const { onActive, onIdle, stopOnIdle } = this.props\n      const { idle } = this.state\n      if (idle) {\n        if (stopOnIdle) {\n          // Clear any existing timeout\n          clearTimeout(this.tId)\n          this.tId = null\n          // Unbind events\n          this._unbindEvents()\n        }\n\n        if (this.manager) {\n          /* istanbul ignore next */\n          this.manager.idle()\n        } else {\n          onIdle(e)\n        }\n      } else {\n        this._bindEvents()\n        if (this.manager) {\n          /* istanbul ignore next */\n          this.manager.active()\n        } else {\n          onActive(e)\n        }\n      }\n    })\n  }\n\n  /**\n   * Event handler for supported event types\n   * @param  {Object} e event object\n   * @private\n   */\n  _handleEvent (e) {\n    const { remaining, pageX, pageY, idle } = this.state\n    const { timeout, stopOnIdle } = this.props\n\n    // Fire onAction event\n    this._onAction(e)\n\n    // Already active, ignore events\n    if (remaining) return\n\n    // Mousemove event\n    if (e.type === 'mousemove') {\n      // If coords are same, it didn't move\n      /* istanbul ignore next */\n      if (e.pageX === pageX && e.pageY === pageY) {\n        return\n      }\n      // If coords don't exist how could it move\n      if (typeof e.pageX === 'undefined' && typeof e.pageY === 'undefined') {\n        return\n      }\n      // Under 200 ms is hard to do\n      // continuous activity will bypass this\n      /* istanbul ignore next */\n      const elapsed = this.getElapsedTime()\n      /* istanbul ignore next */\n      if (elapsed < 200) {\n        return\n      }\n    }\n\n    // Clear any existing timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Determine last time User was active, as can't rely on setTimeout ticking at the correct interval\n    const elapsedTimeSinceLastActive = +new Date() - this.getLastActiveTime()\n\n    // If the user is idle or last active time is more than timeout, flip the idle state\n    if ((idle && !stopOnIdle) || (!idle && elapsedTimeSinceLastActive > timeout)) {\n      this._toggleIdleState(e)\n    }\n\n    // Store when the user was last active\n    // and update the mouse coordinates\n    this.setState({\n      lastActive: +new Date(),\n      pageX: e.pageX,\n      pageY: e.pageY\n    })\n\n    // If the user is idle and stopOnIdle flag is not set\n    // set a new timeout\n    if (idle) {\n      if (!stopOnIdle) {\n        this.tId = setTimeout(this._toggleIdleState, timeout)\n      }\n    } else {\n      this.tId = setTimeout(this._toggleIdleState, timeout)\n    }\n  }\n\n  /**\n   * Set initial state and start timer\n   * @name start\n   */\n  start (remote = true) {\n    // Clear timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Bind the events\n    this._bindEvents()\n\n    // Reset state\n    this.setState({\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      remaining: null\n    })\n\n    if (this.manager) {\n      /* istanbul ignore next */\n      this.manager.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('start')\n      }\n    }\n\n    // Set new timeout\n    const { timeout } = this.props\n    this.tId = setTimeout(this._toggleIdleState, timeout)\n  }\n\n  /**\n   * Restore initial state and restart timer, calling onActive\n   * @name reset\n   */\n  reset (remote = false) {\n    // Clear timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Bind the events\n    this._bindEvents()\n\n    if (this.state.idle) {\n      if (this.manager) {\n        /* istanbul ignore next */\n        this.manager.active()\n      } else {\n        this.props.onActive()\n      }\n    }\n\n    if (this.manager) {\n      /* istanbul ignore next */\n      this.manager.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('reset')\n      }\n    }\n\n    // Reset state\n    this.setState({\n      idle: false,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      remaining: null\n    })\n\n    // Set new timeout\n    const { timeout } = this.props\n    this.tId = setTimeout(this._toggleIdleState, timeout)\n  }\n\n  /**\n   * Store remaining time and stop timer\n   * @name pause\n   */\n  pause (remote = false) {\n    // Timer is already paused\n    const { remaining } = this.state\n    if (remaining !== null) return\n\n    // Unbind events\n    this._unbindEvents()\n\n    // Clear existing timeout\n    clearTimeout(this.tId)\n    this.tId = null\n\n    // Send event to other tabs\n    if (this.manager) {\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('pause')\n      }\n    }\n\n    // Define how much is left on the timer\n    this.setState({\n      remaining: this.getRemainingTime()\n    })\n  }\n\n  /**\n   * Resumes a paused timer\n   * @name resume\n   */\n  resume (remote = false) {\n    // Timer is not paused\n    const { remaining, idle } = this.state\n    if (remaining === null) return\n\n    // Bind events\n    this._bindEvents()\n\n    // Send event to other tabs\n    if (this.manager) {\n      /* istanbul ignore next */\n      if (!remote && this.props.crossTab.emitOnAllTabs) {\n        this.manager.send('resume')\n      }\n    }\n\n    // Start timer and clear remaining\n    // if we are in the active state\n    if (!idle) {\n      // Set a new timeout\n      this.tId = setTimeout(this._toggleIdleState, remaining)\n      // Set new state\n      this.setState({ remaining: null, lastActive: +new Date() })\n    }\n  }\n\n  /**\n   * Time remaining before idle\n   * @name getRemainingTime\n   * @return {number} Milliseconds remaining\n   */\n  getRemainingTime () {\n    const { remaining, lastActive } = this.state\n    const { timeout } = this.props\n\n    // If idle there is no time remaining\n    if (remaining !== null) {\n      return remaining < 0 ? 0 : remaining\n    }\n\n    // Determine remaining, if negative idle didn't finish flipping, just return 0\n    const timeLeft = timeout - ((+new Date()) - lastActive)\n    return timeLeft < 0 ? 0 : timeLeft\n  }\n\n  /**\n   * How much time has elapsed\n   * @name getElapsedTime\n   * @return {Timestamp}\n   */\n  getElapsedTime () {\n    const { oldDate } = this.state\n    return (+new Date()) - oldDate\n  }\n\n  /**\n   * Last time the user was idle\n   * @name getLastIdleTime\n   * @return {Timestamp}\n   */\n  getLastIdleTime () {\n    const { lastIdle } = this.state\n    return lastIdle\n  }\n\n  /**\n   * Total time the user was idle\n   * @name getTotalIdleTime\n   * @return {number}\n   */\n  getTotalIdleTime () {\n    const { idle, lastIdle, idleTime } = this.state\n    if (idle) {\n      return ((+new Date()) - lastIdle) + idleTime\n    } else {\n      return idleTime\n    }\n  }\n\n  /**\n   * Last time the user was active\n   * @name getLastActiveTime\n   * @return {Timestamp}\n   */\n  getLastActiveTime () {\n    const { lastActive } = this.state\n    return lastActive\n  }\n\n  /**\n   * Total time the user was active\n   * @name getTotalActiveTime\n   * @return {number}\n   */\n  getTotalActiveTime () {\n    return this.getElapsedTime() - this.getTotalIdleTime()\n  }\n\n  /**\n   * Returns wether or not the user is idle\n   * @name isIdle\n   * @return {boolean}\n   */\n  isIdle () {\n    const { idle } = this.state\n    return idle\n  }\n\n  /**\n   * Returns wether or not this is the leader tab\n   * @name isLeader\n   * @return {boolean}\n   */\n  isLeader () {\n    return this.manager ? this.manager.isLeader() : true\n  }\n}\n\n/**\n * Type checks for every property\n * @type {Object}\n * @private\n */\nIdleTimer.propTypes = {\n  /**\n   * Activity Timeout in milliseconds\n   * default: 1200000\n   * @type {Number}\n   */\n  timeout: PropTypes.number,\n  /**\n   * DOM events to listen to\n   * default: see [default events](https://github.com/SupremeTechnopriest/react-idle-timer#default-events)\n   * @type {Array}\n   */\n  events: PropTypes.arrayOf(PropTypes.string),\n  /**\n   * Function to call when user is idle\n   * default: () => {}\n   * @type {Function}\n   */\n  onIdle: PropTypes.func,\n  /**\n   * Function to call when user becomes active\n   * default: () => {}\n   * @type {Function}\n   */\n  onActive: PropTypes.func,\n  /**\n   * Function to call on user actions\n   * default: () => {}\n   * @type {Function}\n   */\n  onAction: PropTypes.func,\n  /**\n   * Debounce the onAction function by setting delay in milliseconds\n   * default: 0\n   * @type {Number}\n   */\n  debounce: PropTypes.number,\n  /**\n   * Throttle the onAction function by setting delay in milliseconds\n   * default: 0\n   * @type {Number}\n   */\n  throttle: PropTypes.number,\n  /**\n   * Throttle the event handler function by setting delay in milliseconds\n   * default: 200\n   * @type {Number}\n   */\n  eventsThrottle: PropTypes.number,\n  /**\n   * Element reference to bind activity listeners to\n   * default: document\n   * @type {Object}\n   */\n  element: PropTypes.oneOfType([PropTypes.object, PropTypes.element]),\n  /**\n   * Start the timer on mount\n   * default: true\n   * @type {Boolean}\n   */\n  startOnMount: PropTypes.bool,\n  /**\n   * Require the timer to be started manually.\n   * default: false\n   * @type {Boolean}\n   */\n  startManually: PropTypes.bool,\n  /**\n   * Once the user goes idle the IdleTimer will not\n   * reset on user input instead, reset() must be\n   * called manually to restart the timer\n   * default: false\n   * @type {Boolean}\n   */\n  stopOnIdle: PropTypes.bool,\n  /**\n   * Bind events passively\n   * default: true\n   * @type {Boolean}\n   */\n  passive: PropTypes.bool,\n  /**\n   * Capture events\n   * default: true\n   * @type {Boolean}\n   */\n  capture: PropTypes.bool,\n  /**\n   * Cross Tab functionality.\n   * default: false\n   * @type {Boolean|Object}\n   */\n  crossTab: PropTypes.oneOfType([\n    PropTypes.bool,\n    PropTypes.shape({\n      type: PropTypes.oneOf(['broadcastChannel', 'localStorage', 'simulate']),\n      channelName: PropTypes.string,\n      fallbackInterval: PropTypes.number,\n      responseTime: PropTypes.number,\n      removeTimeout: PropTypes.number,\n      emitOnAllTabs: PropTypes.bool\n    })\n  ])\n}\n\n/**\n * Sets default property values\n * @type {Object}\n * @private\n */\nIdleTimer.defaultProps = {\n  timeout: 1000 * 60 * 20,\n  element: DEFAULT_ELEMENT,\n  events: DEFAULT_EVENTS,\n  onIdle: () => { },\n  onActive: () => { },\n  onAction: () => { },\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: true,\n  startManually: false,\n  stopOnIdle: false,\n  capture: true,\n  passive: true,\n  crossTab: false\n}\n\nexport default IdleTimer\n","/**\n *  ___    _ _     _____ _\n * |_ _|__| | | __|_   _(_)_ __ ___   ___ _ __\n *  | |/ _` | |/ _ \\| | | | '_ ` _ \\ / _ \\ '__|\n *  | | (_| | |  __/| | | | | | | | |  __/ |\n * |___\\__,_|_|\\___||_| |_|_| |_| |_|\\___|_|\n *\n * @name useIdleTimer\n * @author Randy Lebeau\n * @private\n */\n\nimport { useEffect, useRef, useMemo } from 'react'\nimport PropTypes from 'prop-types'\nimport { TabManager } from './TabManager'\nimport { IS_BROWSER, DEFAULT_ELEMENT, DEFAULT_EVENTS, debounced, throttled } from './utils'\n\n/**\n * Detects when your user is idle\n * @function useIdleTimer\n * @private\n */\nfunction useIdleTimer ({\n  timeout = 1000 * 60 * 20,\n  element = DEFAULT_ELEMENT,\n  events = DEFAULT_EVENTS,\n  onIdle = () => { },\n  onActive = () => { },\n  onAction = () => { },\n  debounce = 0,\n  throttle = 0,\n  eventsThrottle = 200,\n  startOnMount = true,\n  startManually = false,\n  stopOnIdle = false,\n  capture = true,\n  passive = true,\n  crossTab = false\n} = {}) {\n  const eventsBound = useRef(false)\n  const idle = useRef(true)\n  const oldDate = useRef(+new Date())\n  const remaining = useRef(null)\n  const pageX = useRef(null)\n  const pageY = useRef(null)\n  const tId = useRef(null)\n  const lastActive = useRef(null)\n  const lastIdle = useRef(null)\n  const idleTime = useRef(0)\n  const firstLoad = useRef(true)\n  const _timeout = useRef(timeout)\n  const manager = useRef(null)\n\n  /* istanbul ignore next */\n  if (crossTab) {\n    if (crossTab === true) crossTab = {}\n    crossTab = Object.assign({\n      channelName: 'idle-timer',\n      fallbackInterval: 2000,\n      responseTime: 100,\n      removeTimeout: 1000 * 60,\n      emitOnAllTabs: false\n    }, crossTab)\n  }\n\n  // Event emitters\n  const emitOnIdle = useRef(onIdle)\n  const emitOnActive = useRef(onActive)\n  const emitOnAction = useRef(onAction)\n\n  useEffect(() => {\n    emitOnIdle.current = onIdle\n  }, [onIdle])\n\n  useEffect(() => {\n    emitOnActive.current = onActive\n  }, [onActive])\n\n  useEffect(() => {\n    emitOnAction.current = onAction\n  }, [onAction])\n\n  const intermediateOnAction = useMemo(() => {\n    function callOnAction (e) {\n      emitOnAction.current(e)\n    }\n\n    // Cancel any existing debounce timeouts\n    if (callOnAction.cancel) callOnAction.cancel()\n\n    // Create debounced action if applicable\n    if (debounce > 0) {\n      return debounced(callOnAction, debounce)\n\n      // Create throttled action if applicable\n    } else if (throttle > 0) {\n      return throttled(callOnAction, throttle)\n\n      // No throttle or debounce\n    } else {\n      return callOnAction\n    }\n  }, [throttle, debounce])\n\n  /**\n   * Toggles the idle state and calls\n   * the correct action function\n   * @private\n   */\n  const _toggleIdleState = e => {\n    const nextIdle = !idle.current\n    idle.current = nextIdle\n    if (nextIdle) {\n      if (stopOnIdle) {\n        // Clear any existing timeout\n        clearTimeout(tId.current)\n        tId.current = null\n        // Unbind events\n        _unbindEvents()\n      }\n      lastIdle.current = (+new Date()) - _timeout.current\n      if (manager.current) {\n        /* istanbul ignore next */\n        manager.current.idle()\n      } else {\n        emitOnIdle.current(e)\n      }\n    } else {\n      idleTime.current += (+new Date()) - lastIdle.current\n      _bindEvents()\n      if (manager.current) {\n        /* istanbul ignore next */\n        manager.current.active()\n      } else {\n        emitOnActive.current(e)\n      }\n    }\n  }\n\n  /**\n   * Event handler\n   * @param {Event} e\n   */\n  const _handleEvent = e => {\n    // Fire onAction event\n    intermediateOnAction(e)\n\n    // Already active, ignore events\n    if (remaining.current) return\n\n    // Mousemove event\n    /* istanbul ignore next */\n    if (e.type === 'mousemove') {\n      // If coords are same, it didn't move\n      if (e.pageX === pageX && e.pageY === pageY) {\n        return\n      }\n      // If coords don't exist how could it move\n      if (typeof e.pageX === 'undefined' && typeof e.pageY === 'undefined') {\n        return\n      }\n      // Under 200 ms is hard to do\n      // continuous activity will bypass this\n      const elapsed = getElapsedTime()\n      if (elapsed < 200) {\n        return\n      }\n    }\n\n    // Clear any existing timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Determine last time User was active, as can't rely on setTimeout ticking at the correct interval\n    const elapsedTimeSinceLastActive = +new Date() - getLastActiveTime()\n\n    // If the user is idle or last active time is more than timeout, flip the idle state\n    if (\n      (idle.current && !stopOnIdle) ||\n      (!idle.current && elapsedTimeSinceLastActive > _timeout.current)\n    ) {\n      _toggleIdleState(e)\n    }\n\n    // Store when the user was last active\n    // and update the mouse coordinates\n    lastActive.current = +new Date()\n    pageX.current = e.pageX\n    pageY.current = e.pageY\n\n    // If the user is active, set a new timeout\n    if (!idle.current) {\n      tId.current = setTimeout(_toggleIdleState, _timeout.current)\n    }\n  }\n\n  /**\n   * Reference to current handleEvent function.\n   * @private\n   */\n  const handleEvent = useRef(_handleEvent)\n\n  /**\n   * Binds the specified events\n   * @private\n   */\n  const _bindEvents = () => {\n    // Don't bind events if\n    // we are not in a browser\n    if (!IS_BROWSER) return\n    // Otherwise we bind all the events\n    // to the supplied element\n    if (!eventsBound.current) {\n      events.forEach(e => {\n        element.addEventListener(e, handleEvent.current, {\n          capture,\n          passive\n        })\n      })\n      eventsBound.current = true\n    }\n  }\n\n  /**\n   * Unbinds all the bound events\n   * @private\n   */\n  const _unbindEvents = (force = false) => {\n    // If we are not in a browser\n    // we don't need to unbind events\n    if (!IS_BROWSER) return\n    // Unbind all events\n    if (eventsBound.current || force) {\n      events.forEach(e => {\n        element.removeEventListener(e, handleEvent.current, {\n          capture,\n          passive\n        })\n      })\n      eventsBound.current = false\n    }\n  }\n\n  /**\n   * Time remaining before idle\n   * @name getRemainingTime\n   * @return {number} Milliseconds remaining\n   */\n  const getRemainingTime = () => {\n    // If idle there is no time remaining\n    if (remaining.current !== null) {\n      return remaining.current < 0 ? 0 : remaining.current\n    }\n\n    // Determine remaining, if negative idle didn't finish flipping, just return 0\n    const timeLeft = _timeout.current - ((+new Date()) - lastActive.current)\n    return timeLeft < 0 ? 0 : timeLeft\n  }\n\n  /**\n   * How much time has elapsed\n   * @name getElapsedTime\n   * @return {Timestamp}\n   */\n  const getElapsedTime = () => (+new Date()) - oldDate.current\n\n  /**\n   * Last time the user was idle\n   * @name getLastIdleTime\n   * @return {Timestamp}\n   */\n  const getLastIdleTime = () => lastIdle.current\n\n  /**\n   * Get the total time user is idle\n   * @name getTotalIdleTime\n   * @return {number} Milliseconds idle\n   */\n  const getTotalIdleTime = () => {\n    if (idle.current) {\n      return ((+new Date()) - lastIdle.current) + idleTime.current\n    } else {\n      return idleTime.current\n    }\n  }\n\n  /**\n   * Last time the user was active\n   * @name getLastActiveTime\n   * @return {Timestamp}\n   */\n  const getLastActiveTime = () => lastActive.current\n\n  /**\n   * Get the total time user is active\n   * @name getTotalActiveTime\n   * @return {number} Milliseconds active\n   */\n  const getTotalActiveTime = () => getElapsedTime() - getTotalIdleTime()\n\n  /**\n   * Returns wether or not the user is idle\n   * @name isIdle\n   * @return {Boolean}\n   */\n  const isIdle = () => idle.current\n\n  /**\n   * Returns wether or not this is the leader tab\n   * @returns {Boolean}\n   */\n  const isLeader = () => manager.current ? manager.current.isLeader() : true\n\n  /**\n  * Set initial state and start timer\n  * @name reset\n  */\n  const start = (remote = false) => {\n    // Clear timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Bind the events\n    _bindEvents()\n\n    // Set state\n    idle.current = false\n    oldDate.current = +new Date()\n    lastActive.current = +new Date()\n    remaining.current = null\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      manager.current.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('start')\n      }\n    }\n\n    // Set new timeout\n    tId.current = setTimeout(_toggleIdleState, _timeout.current)\n  }\n\n  /**\n  * Restore initial state and restart timer, calling onActive\n  * @name reset\n  */\n  const reset = (remote = false) => {\n    // Clear timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Bind the events\n    _bindEvents()\n\n    // Emit active\n    if (idle.current) {\n      if (manager.current) {\n        /* istanbul ignore next */\n        manager.current.active()\n      } else {\n        emitOnActive.current()\n      }\n    }\n\n    // Reset state\n    idle.current = false\n    oldDate.current = +new Date()\n    lastActive.current = +new Date()\n    remaining.current = null\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      manager.current.setAllIdle(false)\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('reset')\n      }\n    }\n\n    // Set new timeout\n    tId.current = setTimeout(_toggleIdleState, _timeout.current)\n  }\n\n  /**\n   * Store remaining time and stop timer\n   * @name pause\n   */\n  const pause = (remote = false) => {\n    // Timer is already paused\n    if (remaining.current !== null) return\n\n    // Unbind events\n    _unbindEvents()\n\n    // Clear existing timeout\n    clearTimeout(tId.current)\n    tId.current = null\n\n    // Define how much is left on the timer\n    remaining.current = getRemainingTime()\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('pause')\n      }\n    }\n  }\n\n  /**\n   * Resumes a paused timer\n   * @name resume\n   */\n  const resume = (remote = false) => {\n    // Timer is not paused\n    if (remaining.current === null) return\n\n    // Bind events\n    _bindEvents()\n\n    // Start timer and clear remaining\n    // if we are in the idle state\n    if (!idle.current) {\n      // Set a new timeout\n      tId.current = setTimeout(_toggleIdleState, remaining.current)\n      // Set states\n      remaining.current = null\n      lastActive.current = +new Date()\n    }\n\n    if (manager.current) {\n      /* istanbul ignore next */\n      if (!remote && crossTab.emitOnAllTabs) {\n        manager.current.send('resume')\n      }\n    }\n  }\n\n  /**\n   * Hook lifecycle\n   */\n  useEffect(() => {\n    // Debounce and throttle can't both be set\n    if (debounce > 0 && throttle > 0) {\n      throw new Error('onAction can either be throttled or debounced (not both)')\n    }\n\n    // Set up cross tab\n    /* istanbul ignore next */\n    if (crossTab) {\n      manager.current = TabManager({\n        type: crossTab.type,\n        channelName: crossTab.channelName,\n        fallbackInterval: crossTab.fallbackInterval,\n        responseTime: crossTab.responseTime,\n        emitOnAllTabs: crossTab.emitOnAllTabs,\n        callbacks: {\n          onIdle: emitOnIdle.current,\n          onActive: emitOnActive.current\n        },\n        start,\n        reset,\n        pause,\n        resume\n      })\n    }\n\n    // If startOnMount is enabled, start the timer\n    if (startManually) {\n      return async () => {\n        clearTimeout(tId.current)\n        _unbindEvents(true)\n        if (crossTab) await manager.current.close()\n      }\n    }\n\n    if (startOnMount) {\n      start()\n    } else {\n      _bindEvents()\n    }\n\n    // Clear and unbind on unmount\n    return async () => {\n      clearTimeout(tId.current)\n      _unbindEvents(true)\n      if (intermediateOnAction.cancel) intermediateOnAction.cancel()\n      if (crossTab) await manager.current.close()\n    }\n  }, [])\n\n  useEffect(() => {\n    const eventsWereBound = eventsBound.current\n    if (eventsWereBound) _unbindEvents()\n    if (eventsThrottle > 0) {\n      handleEvent.current = throttled(_handleEvent, eventsThrottle)\n    } else {\n      handleEvent.current = _handleEvent\n    }\n    if (eventsWereBound) _bindEvents()\n  }, [eventsThrottle])\n\n  useEffect(() => {\n    _timeout.current = timeout\n    if (!firstLoad.current && idle.current) {\n      reset()\n    }\n    firstLoad.current = false\n  }, [timeout])\n\n  return {\n    isIdle,\n    isLeader,\n    start,\n    pause,\n    reset,\n    resume,\n    getLastIdleTime,\n    getTotalIdleTime,\n    getLastActiveTime,\n    getTotalActiveTime,\n    getElapsedTime,\n    getRemainingTime\n  }\n}\n\n/**\n * Type checks for every property\n * @type {Object}\n * @private\n */\nuseIdleTimer.propTypes = {\n  /**\n   * Activity Timeout in milliseconds\n   * default: 1200000\n   * @type {number}\n   */\n  timeout: PropTypes.number,\n  /**\n   * DOM events to listen to\n   * default: see [default events](https://github.com/SupremeTechnopriest/react-idle-timer#default-events)\n   * @type {Array}\n   */\n  events: PropTypes.arrayOf(PropTypes.string),\n  /**\n   * Function to call when user is idle.\n   * default: () => {}\n   * @type {Function}\n   */\n  onIdle: PropTypes.func,\n  /**\n   * Function to call when user becomes active.\n   * default: () => {}\n   * @type {Function}\n   */\n  onActive: PropTypes.func,\n  /**\n   * Function to call on user actions.\n   * default: () => {}\n   * @type {Function}\n   */\n  onAction: PropTypes.func,\n  /**\n   * Debounce the onAction function by setting delay in milliseconds.\n   * default: 0\n   * @type {number}\n   */\n  debounce: PropTypes.number,\n  /**\n   * Throttle the onAction function by setting delay in milliseconds.\n   * default: 0\n   * @type {number}\n   */\n  throttle: PropTypes.number,\n  /**\n   * Throttle the event handler function by setting delay in milliseconds.\n   * default: 200\n   * @type {number}\n   */\n  eventsThrottle: PropTypes.number,\n  /**\n   * Element reference to bind activity listeners to.\n   * default: document\n   * @type {Object}\n   */\n  element: PropTypes.oneOfType([PropTypes.object, PropTypes.element]),\n  /**\n   * Start the timer on mount.\n   * default: true\n   * @type {Boolean}\n   */\n  startOnMount: PropTypes.bool,\n  /**\n   * Require the timer to be started manually.\n   * default: false\n   * @type {Boolean}\n   */\n  startManually: PropTypes.bool,\n  /**\n   * Once the user goes idle the IdleTimer will not\n   * reset on user input instead, start() or reset() must be\n   * called manually to restart the timer.\n   * default: false\n   * @type {Boolean}\n   */\n  stopOnIdle: PropTypes.bool,\n  /**\n   * Bind events passively.\n   * default: true\n   * @type {Boolean}\n   */\n  passive: PropTypes.bool,\n  /**\n   * Capture events.\n   * default: true\n   * @type {Boolean}\n   */\n  capture: PropTypes.bool,\n  /**\n   * Cross Tab functionality.\n   * default: false\n   * @type {Boolean|Object}\n   */\n  crossTab: PropTypes.oneOfType([\n    PropTypes.bool,\n    PropTypes.shape({\n      type: PropTypes.oneOf(['broadcastChannel', 'localStorage', 'simulate']),\n      channelName: PropTypes.string,\n      fallbackInterval: PropTypes.number,\n      responseTime: PropTypes.number,\n      removeTimeout: PropTypes.number,\n      emitOnAllTabs: PropTypes.bool\n    })\n  ])\n}\n\n/**\n * Sets default property values\n * @type {Object}\n * @private\n */\nuseIdleTimer.defaultProps = {\n  timeout: 1000 * 60 * 20,\n  element: DEFAULT_ELEMENT,\n  events: DEFAULT_EVENTS,\n  onIdle: () => { },\n  onActive: () => { },\n  onAction: () => { },\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: true,\n  startManually: false,\n  stopOnIdle: false,\n  capture: true,\n  passive: true,\n  crossTab: false\n}\n\nexport default useIdleTimer\n"],"mappings":";;;;;;;;;;;;AAMO,IAAMA,CAAA,GACuD,cAA/C,sBAAXC,MAAA,0BAA8CA,MAAA,GAArB,cAAAC,CAAA,CAAqBD,MAAA;EAO3CE,CAAA,GAAkBH,CAAA,GAAaI,QAAA,GAAW;EAO1CC,CAAA,GAAiB,CAC5B,aACA,WACA,SACA,kBACA,cACA,aACA,cACA,aACA,iBACA,iBACA;AAaK,SAASC,EAAWC,CAAA,EAAIC,CAAA;EAAA,IACzBC,CAAA;EAAA,SACKC,EAAA;IAAA,SAAAA,CAAA,GAAAC,SAAA,CAAAC,MAAA,EAAWC,CAAA,OAAAC,KAAA,CAAAJ,CAAA,GAAAK,CAAA,MAAAA,CAAA,GAAAL,CAAA,EAAAK,CAAA,IAAAF,CAAA,CAAAE,CAAA,IAAAJ,SAAA,CAAAI,CAAA;IACdN,CAAA,IACFO,YAAA,CAAaP,CAAA,GAEfA,CAAA,GAAUQ,UAAA,CAAW;MACnBV,CAAA,CAAAW,KAAA,SAAML,CAAA,GACNJ,CAAA,GAAU;IAAA,GACTD,CAAA;EAAA;EAAA,OAGLE,CAAA,CAAOS,MAAA,GAAS;IACdH,YAAA,CAAaP,CAAA;EAAA,GAGRC,CAAA;AAAA;AAYF,SAASU,EAAWb,CAAA,EAAIC,CAAA;EAAA,IACzBC,CAAA,GAAW;EAAA,OACR;IAAA,IACCC,CAAA,GAAM,IAAIW,IAAA,GAAOC,OAAA;IAAA,MACnBZ,CAAA,GAAMD,CAAA,GAAWD,CAAA,UAGrBC,CAAA,GAAWC,CAAA,EACJH,CAAA,CAAAW,KAAA,SAAAP,SAAA;EAAA;AAAA;AAIX,IAAIY,CAAA,GAAS;EACTC,CAAA,GAAa;AAQV,SAASC,EAAA;EAAA,IACRlB,CAAA,GAAK,IAAIc,IAAA,GAAOC,OAAA;EAAA,OAClBf,CAAA,KAAOgB,CAAA,GAEG,MAALhB,CAAA,KADPiB,CAAA,IAGAD,CAAA,GAAShB,CAAA,EACTiB,CAAA,GAAa,GACD,MAALjB,CAAA;AAAA;AAUJ,SAASmB,EAAA;EAAA,OACPC,IAAA,CAAKC,MAAA,GAASC,QAAA,CAAS,IAAIC,SAAA,CAAU;AAAA;AAyBvC,SAASC,EAAA;EAAA,IAAOxB,CAAA,GAAAI,SAAA,CAAAC,MAAA,mBAAAD,SAAA,MAAAA,SAAA,MAAO;EAAA,OACrB,IAAIqB,OAAA,CAAQ,UAAAxB,CAAA;IAAA,OAAWS,UAAA,CAAWT,CAAA,EAASD,CAAA;EAAA;AAAA;AAS7C,SAAS0B,EAAA;EAAA,OACP,IAAIZ,IAAA,GAAOC,OAAA;AAAA;AClGpB,IAAAY,CAAA,GAAe;IACbC,MAAA,EA/CK,SAAAA,CAAiB5B,CAAA;MAAA,IAChBC,CAAA,GAAQ;QACZ4B,gBAAA,EAAkB;QAClBC,EAAA,EAAI,IAAIC,gBAAA,CAAiB/B,CAAA;MAAA;MAAA,OAG3BC,CAAA,CAAM6B,EAAA,CAAGE,SAAA,GAAY,UAAAhC,CAAA;QACfC,CAAA,CAAM4B,gBAAA,IACR5B,CAAA,CAAM4B,gBAAA,CAAiB7B,CAAA,CAAIiC,IAAA;MAAA,GAIxBhC,CAAA;IAAA;IAoCPiC,KAAA,EAjCK,SAAAA,CAAgBlC,CAAA;MACrBA,CAAA,CAAa8B,EAAA,CAAGI,KAAA;IAAA;IAiChBC,SAAA,EApBK,SAAAA,CAAoBnC,CAAA,EAAcC,CAAA;MACvCD,CAAA,CAAa6B,gBAAA,GAAmB5B,CAAA;IAAA;IAoBhCmC,WAAA,EA/BK,SAAAA,CAAsBpC,CAAA,EAAcC,CAAA;MAAA;QAAA,OAEvCD,CAAA,CAAa8B,EAAA,CAAGM,WAAA,CAAYnC,CAAA,GAAa,IAClCwB,OAAA,CAAQY,OAAA;MAAA,CACf,QAAOrC,CAAA;QAAA,OAEAyB,OAAA,CAAQa,MAAA,CAAOtC,CAAA;MAAA;IAAA;IA0BxBuC,SAAA,EAlBK,SAAAA,CAAA;MAAA,OAC2B,qBAArBR,gBAAA;IAAA;IAkBXS,IAAA,EAtDkB;IAuDlBC,mBAAA,EAXK,SAAAA,CAAA;MAAA,OACE;IAAA;IAWPC,YAAA,EAAAxB;EAAA;ECzDmByB,CAAA;IAAA,SAAAzC,EAAA;MAAA,IACND,CAAA,GAAAG,SAAA,CAAAC,MAAA,mBAAAD,SAAA,MAAAA,SAAA,MAAM;MAAAJ,CAAA,OAAAE,CAAA,QACZ0C,GAAA,GAAM3C,CAAA,OACN4C,GAAA,GAAM,IAAIC,GAAA,SACVC,OAAA,GAAU,IAAIC,GAAA;IAAA;IAAA,OAAA/C,CAAA,CAAAC,CAAA;MAAA+C,GAAA;MAAAC,KAAA,EAGrB,SAAAF,CAAKhD,CAAA;QAAA,OACI,KAAK6C,GAAA,CAAIM,GAAA,CAAInD,CAAA;MAAA;IAAA;MAAAiD,GAAA;MAAAC,KAAA,EAGtB,SAAAA,CAAKlD,CAAA;QAAA,KACE+C,OAAA,CAAQF,GAAA,CAAI7C,CAAA,EAAO0B,CAAA,UACnBmB,GAAA,CAAIO,GAAA,CAAIpD,CAAA,QACRqD,mBAAA;MAAA;IAAA;MAAAJ,GAAA;MAAAC,KAAA,EAGP,SAAAG,CAAA;QAAA,KACOR,GAAA,CAAIS,KAAA,SACJP,OAAA,CAAQO,KAAA;MAAA;IAAA;MAAAL,GAAA;MAAAC,KAAA,EAGf,SAAAI,CAAA;QAAA,SACQtD,CAAA,GAAY0B,CAAA,KAAQ,KAAKkB,GAAA,EACzB3C,CAAA,GAAW,KAAK4C,GAAA,CAAIU,MAAA,CAAOC,QAAA,OAEpB;UAAA,IACLtD,CAAA,GAAQD,CAAA,CAASwD,IAAA,GAAOP,KAAA;UAAA,KACzBhD,CAAA,EAAO;UAAA,MACC,KAAK6C,OAAA,CAAQW,GAAA,CAAIxD,CAAA,IACnBF,CAAA;UAAA,KACJ+C,OAAA,CAAAY,MAAA,CAAezD,CAAA,QACf2C,GAAA,CAAAc,MAAA,CAAWzD,CAAA;QAAA;MAAA;IAAA,KAAAA,CAAA;EAAA;ACtBjB,SAAS0D,EAAA;EAAA,IACV5D,CAAA;EAAA,IACkB,sBAAXN,MAAA,EAAwB,OAAO;EAAA;IAExCM,CAAA,GAAeN,MAAA,CAAOmE,YAAA,EACtB7D,CAAA,GAAeN,MAAA,CAAO,gCAAgCA,MAAA,CAAOmE,YAAA;EAAA,CAC7D,QAAO7D,CAAA;EAAA,OAKFA,CAAA;AAAA;AAsCF,SAAS8D,EAAyB9D,CAAA,EAAaC,CAAA;EAAA,IAC9CC,CAAA,GAAiBF,CAAA;IACjBG,CAAA,GAAW,SAAA4D,CAAA/D,CAAA;MACXA,CAAA,CAAGiD,GAAA,KAAQ/C,CAAA,IACbD,CAAA,CAAG+D,IAAA,CAAKC,KAAA,CAAMjE,CAAA,CAAGkE,QAAA;IAAA;EAAA,OAGrBxE,MAAA,CAAOyE,gBAAA,CAAiB,WAAWhE,CAAA,GAC5BA,CAAA;AAAA;AAoDF,SAASiE,EAAA;EAAA,IACRpE,CAAA,GAAK4D,CAAA;EAAA,KAEN5D,CAAA,EAAI,QAAO;EAAA;IAAA,IAGRC,CAAA,GAAM;IACZD,CAAA,CAAGqE,OAAA,CAAQpE,CAAA,EAAK,UAChBD,CAAA,CAAGsE,UAAA,CAAWrE,CAAA;EAAA,CACd,QAAOD,CAAA;IAAA,QAMA;EAAA;EAAA,QAGF;AAAA;AAcT,IAAAuE,CAAA,GAAe;IACb3C,MAAA,EA/EK,SAAAA,CAAiB5B,CAAA;MAAA,IAAaC,CAAA,GAAAG,SAAA,CAAAC,MAAA,mBAAAD,SAAA,MAAAA,SAAA,MAAU;MAAA,KACxCgE,CAAA,UAEG,IAAII,KAAA,CAAM;MAAA,IAGZtE,CAAA,GAAOiB,CAAA;QAOPhB,CAAA,GAAO,IAAIwC,CAAA,CAAa1C,CAAA,CAAQwE,aAAA;QAEhCnE,CAAA,GAAQ;UACZoE,WAAA,EAAA1E,CAAA;UACA2E,IAAA,EAAAzE,CAAA;UACA0E,IAAA,EAAAzE;QAAA;MAAA,OAGFG,CAAA,CAAMyD,QAAA,GAAWD,CAAA,CACf9D,CAAA,EACA,UAACA,CAAA;QACMM,CAAA,CAAMuB,gBAAA,IACP7B,CAAA,CAAO2E,IAAA,KAASzE,CAAA,IACfF,CAAA,CAAO6E,KAAA,KAAS1E,CAAA,CAAKgD,GAAA,CAAInD,CAAA,CAAO6E,KAAA,MACjC7E,CAAA,CAAOiC,IAAA,CAAK6C,IAAA,IAAQ9E,CAAA,CAAOiC,IAAA,CAAK6C,IAAA,GAAOxE,CAAA,CAAMyE,oBAAA,KAEjD5E,CAAA,CAAKiD,GAAA,CAAIpD,CAAA,CAAO6E,KAAA,GAChBvE,CAAA,CAAMuB,gBAAA,CAAiB7B,CAAA,CAAOiC,IAAA;MAAA,IAI3B3B,CAAA;IAAA;IA8CP4B,KAAA,EA3CK,SAAAA,CAAgBlC,CAAA;MAzChB,IAAqCC,CAAA;MAAAA,CAAA,GA0CfD,CAAA,CAAa+D,QAAA,EAzCxCrE,MAAA,CAAOsF,mBAAA,CAAoB,WAAW/E,CAAA;IAAA;IAoFtCkC,SAAA,EAxCK,SAAAA,CAAoBnC,CAAA,EAAcC,CAAA,EAAIC,CAAA;MAC3CF,CAAA,CAAa+E,oBAAA,GAAuB7E,CAAA,EACpCF,CAAA,CAAa6B,gBAAA,GAAmB5B,CAAA;IAAA;IAuChCmC,WAAA,EA3HK,SAAAA,CAAsBpC,CAAA,EAAcC,CAAA;MAAA,OAClC,IAAIwB,OAAA,CAAQ,UAAAvB,CAAA;QAAA,IACXC,CAAA,GAAiBH,CAAA,CAAa0E,WAAA;UAC9BpE,CAAA,GAAW;YACfuE,KAAA,EAAO1D,CAAA;YACP2D,IAAA,EAAM,IAAIhE,IAAA,GAAOC,OAAA;YACjBkB,IAAA,EAAMhC,CAAA;YACN0E,IAAA,EAAM3E,CAAA,CAAa2E;UAAA;UAEfnE,CAAA,GAAQwD,IAAA,CAAKiB,SAAA,CAAU3E,CAAA;QAC7BsD,CAAA,GAAkBS,OAAA,CAAQlE,CAAA,EAAKK,CAAA;QAAA,IAOzB0E,CAAA,GAAKrF,QAAA,CAASsF,WAAA,CAAY;QAChCD,CAAA,CAAGE,SAAA,CAAU,YAAW,IAAM,IAC9BF,CAAA,CAAGjC,GAAA,GAAM9C,CAAA,EACT+E,CAAA,CAAGhB,QAAA,GAAW1D,CAAA,EACdd,MAAA,CAAO2F,aAAA,CAAcH,CAAA,GAErBhF,CAAA;MAAA;IAAA;IAqGFqC,SAAA,EAAA6B,CAAA;IACA5B,IAAA,EAxJkB;IAyJlBC,mBAAA,EAjBK,SAAAA,CAAA;MAAA,IAECzC,CAAA,GAAYsF,SAAA,CAAUC,SAAA,CAAUC,WAAA;MAAA,OAClCxF,CAAA,CAAUyF,QAAA,CAAS,cAAczF,CAAA,CAAUyF,QAAA,CAAS,YAE/C,MAJW;IAAA;IAiBpB/C,YAAA,EAAAxB;EAAA;EC7JIwE,CAAA,GAAoB,IAAI5C,GAAA;AA0C9B,IAAA6C,CAAA,GAAe;IACb/D,MAAA,EAzCK,SAAAA,CAAiB5B,CAAA;MAAA,IAChBC,CAAA,GAAQ;QACZ2F,IAAA,EAAM5F,CAAA;QACN6B,gBAAA,EAAkB;MAAA;MAAA,OAEpB6D,CAAA,CAAkBtC,GAAA,CAAInD,CAAA,GAEfA,CAAA;IAAA;IAmCPiC,KAAA,EAhCK,SAAAA,CAAgBlC,CAAA;MACrB0F,CAAA,CAAA/B,MAAA,CAAyB3D,CAAA;IAAA;IAgCzBmC,SAAA,EAjBK,SAAAA,CAAoBnC,CAAA,EAAcC,CAAA;MACvCD,CAAA,CAAa6B,gBAAA,GAAmB5B,CAAA;IAAA;IAiBhCmC,WAAA,EA9BK,SAAAA,CAAsBpC,CAAA,EAAcC,CAAA;MAAA,OAClC,IAAIwB,OAAA,CAAQ,UAAAvB,CAAA;QAAA,OAAWQ,UAAA,CAAW;UAClBH,KAAA,CAAMsF,IAAA,CAAKH,CAAA,EAE7BI,MAAA,CAAO,UAAA7F,CAAA;YAAA,OAAWA,CAAA,CAAQ2F,IAAA,KAAS5F,CAAA,CAAa4F,IAAA;UAAA,GAChDE,MAAA,CAAO,UAAA7F,CAAA;YAAA,OAAWA,CAAA,KAAYD,CAAA;UAAA,GAC9B8F,MAAA,CAAO,UAAA9F,CAAA;YAAA,SAAaA,CAAA,CAAQ6B,gBAAA;UAAA,GAC5BkE,OAAA,CAAQ,UAAA/F,CAAA;YAAA,OAAWA,CAAA,CAAQ6B,gBAAA,CAAiB5B,CAAA;UAAA,IAC/CC,CAAA;QAAA,GACC;MAAA;IAAA;IAsBHqC,SAAA,EAdK,SAAAA,CAAA;MAAA,QACE;IAAA;IAcPC,IAAA,EAlDkB;IAmDlBC,mBAAA,EAXK,SAAAA,CAAA;MAAA,OACE;IAAA;IAWPC,YAAA,EAAAxB;EAAA;ECjDI8E,CAAA,GAAU,CACdrE,CAAA,EACA4C,CAAA;AAGK,SAAS0B,EAAA;EAAA,IAAcjG,CAAA,GAAAI,SAAA,CAAAC,MAAA,mBAAAD,SAAA,MAAAA,SAAA,MAAU;EAAA,IAClCJ,CAAA,CAAQwC,IAAA,EAAM;IAAA,IAEK,eAAjBxC,CAAA,CAAQwC,IAAA,SACHmD,CAAA;IAAA,IAIH1F,CAAA,GAAS+F,CAAA,CAAQE,IAAA,CAAK,UAAAjG,CAAA;MAAA,OAAKA,CAAA,CAAEuC,IAAA,KAASxC,CAAA,CAAQwC,IAAA;IAAA;IAAA,IAC/CvC,CAAA,EACA,OAAOA,CAAA;IADC,MAAM,IAAIuE,KAAA,aAAA2B,MAAA,CAAkBnG,CAAA,CAAQwC,IAAA;EAAA;EAAA,IAI7CtC,CAAA,GAAY8F,CAAA,CAAQE,IAAA,CAAK,UAAAlG,CAAA;IAAA,OAAUA,CAAA,CAAOuC,SAAA;EAAA;EAAA,KAG3CrC,CAAA,QACG,IAAIsE,KAAA,sBAAA2B,MAAA,CAA2BnC,IAAA,CAAKiB,SAAA,CAAUe,CAAA,CAAQI,GAAA,CAAI,UAAApG,CAAA;IAAA,OAAKA,CAAA,CAAEwC,IAAA;EAAA;EAAA,OAElEtC,CAAA;AAAA;AAAA,IC1BImG,CAAA;EAAA,SAAAnG,EACED,CAAA;IAAA,IAAME,CAAA,GAAAC,SAAA,CAAAC,MAAA,mBAAAD,SAAA,MAAAA,SAAA,MAAU;IAAAJ,CAAA,OAAAE,CAAA,QACtB0F,IAAA,GAAO3F,CAAA,OACPqG,OAAA,GAAUnG,CAAA,OACVoG,MAAA,GAASN,CAAA,CAAa,KAAKK,OAAA,QAC3BE,MAAA,IAAS,QAGTC,YAAA,IAAe,QAOfC,kBAAA,GAAqB,WAKrBC,kBAAA,GAAqB;MACxBC,OAAA,EAAS;MACTC,QAAA,EAAU;IAAA,QAQPC,sBAAA,GAAyB,IAAIhE,GAAA,SAO7BiE,YAAA,GAAe,SAKfC,gBAAA,GAAmB,MACxBC,CAAA,CAAgB;EAAA;EAAA,OAAAhH,CAAA,CAAAC,CAAA;IAAA+C,GAAA;IAAAC,KAAA,EAGlB,SAAAgE,CAAalH,CAAA;MAAA,IACP,KAAKwG,MAAA,QACD,IAAIhC,KAAA,CACR;MAAA,OAGG2C,CAAA,CAAM,MAAM,WAAWnH,CAAA;IAAA;EAAA;IAAAiD,GAAA;IAAAC,KAAA,EAGhC,SAAAkE,CAAcpH,CAAA;MAAA,OACLmH,CAAA,CAAM,MAAM,YAAYnH,CAAA;IAAA;EAAA;IAAAiD,GAAA;IAAAS,GAAA,WAAAA,CAAA;MAAA,OAqBxB,KAAKgD,kBAAA;IAAA;IAAA7D,GAAA,EAlBd,SAAA6D,CAAe1G,CAAA;MAAA,IAEPC,CAAA,GAAY;QAChB6E,IAAA,EAFW,KAAKyB,MAAA,CAAO7D,YAAA;QAGvB2E,EAAA,EAAArH;MAAA;MAEFsH,CAAA,CAAsB,MAAM,WAAW,KAAKZ,kBAAA,GACxC1G,CAAA,IAAoB,qBAAPA,CAAA,SACV0G,kBAAA,GAAqBzG,CAAA,EAC1BsH,CAAA,CAAmB,MAAM,WAAWtH,CAAA,UAG/ByG,kBAAA,GAAqB;IAAA;EAAA;IAAAzD,GAAA;IAAAC,KAAA,EAS9B,SAAAA,CAAkBlD,CAAA,EAAMC,CAAA;MAMtBsH,CAAA,CAAmB,MAAMvH,CAAA,EAJP;QAChB8E,IAAA,EAFW,KAAKyB,MAAA,CAAO7D,YAAA;QAGvB2E,EAAA,EAAApH;MAAA;IAAA;EAAA;IAAAgD,GAAA;IAAAC,KAAA,EAKJ,SAAAmE,CAAqBrH,CAAA,EAAMC,CAAA;MAEzBqH,CAAA,CAAsB,MAAMtH,CAAA,EADhB,KAAK2G,kBAAA,CAAmB3G,CAAA,EAAMkG,IAAA,CAAK,UAAAlG,CAAA;QAAA,OAAOA,CAAA,CAAIqH,EAAA,KAAOpH,CAAA;MAAA;IAAA;EAAA;IAAAgD,GAAA;IAAAC,KAAA,EAInE,SAAAmE,CAAA;MAAA,IAAArH,CAAA;MAAA,KACM,KAAKwG,MAAA;QAAA,KAGJA,MAAA,IAAS;QAAA,IACRvG,CAAA,GAAe,KAAK+G,gBAAA,GAAmB,KAAKA,gBAAA,GAAmBvF,OAAA,CAAQY,OAAA;QAAA,YAExEqE,kBAAA,GAAqB,WACrBC,kBAAA,CAAmBC,OAAA,GAAU,IAE3B3G,CAAA,CAEJuH,IAAA,CAAK;UAAA,OAAM/F,OAAA,CAAQgG,GAAA,CAAIlH,KAAA,CAAMsF,IAAA,CAAK7F,CAAA,CAAK8G,sBAAA;QAAA,GAEvCU,IAAA,CAAK;UAAA,OAAM/F,OAAA,CAAQgG,GAAA,CAAIzH,CAAA,CAAK+G,YAAA,CAAaX,GAAA,CAAI,UAAApG,CAAA;YAAA,OAAMA,CAAA;UAAA;QAAA,GAEnDwH,IAAA,CAAK;UAAA,OAAMxH,CAAA,CAAKuG,MAAA,CAAOrE,KAAA,CAAMlC,CAAA,CAAK0H,MAAA;QAAA;MAAA;IAAA;EAAA;IAAAzE,GAAA;IAAAS,GAAA,EAGvC,SAAAgE,CAAA;MAAA,OACS,KAAKnB,MAAA,CAAO/D,IAAA;IAAA;EAAA;IAAAS,GAAA;IAAAC,KAAA,EAGrB,SAAAV,CAAA;MAAA,OACS,KAAKgE,MAAA;IAAA;EAAA,KAAAtG,CAAA;AAAA;AAIhB,SAASiH,EAAOnH,CAAA,EAAgBC,CAAA,EAAMC,CAAA;EAAA,IAE9BC,CAAA,GAAS;IACb2E,IAAA,EAFW9E,CAAA,CAAeuG,MAAA,CAAO7D,YAAA;IAGjCF,IAAA,EAAAvC,CAAA;IACAgC,IAAA,EAAM/B;EAAA;EAAA,QAGaF,CAAA,CAAegH,gBAAA,GAAmBhH,CAAA,CAAegH,gBAAA,GAAmBvF,OAAA,CAAQY,OAAA,IAC7EmF,IAAA,CAAK;IAAA,IACjBvH,CAAA,GAAcD,CAAA,CAAeuG,MAAA,CAAOnE,WAAA,CACxCpC,CAAA,CAAe0H,MAAA,EACfvH,CAAA;IAAA,OAIFH,CAAA,CAAe8G,sBAAA,CAAuB1D,GAAA,CAAInD,CAAA,GAC1CA,CAAA,CAAA0H,KAAA,GAEGH,IAAA,CAAK;MAAA,OAAMxH,CAAA,CAAe8G,sBAAA,CAAAnD,MAAA,CAA8B1D,CAAA;IAAA,IAEpDA,CAAA;EAAA;AAAA;AAIX,SAASgH,EAAiBjH,CAAA;EAAA,IN5BCC,CAAA;IM6BnBC,CAAA,GAAeF,CAAA,CAAQuG,MAAA,CAAO3E,MAAA,CAAO5B,CAAA,CAAQ4F,IAAA,EAAM5F,CAAA,CAAQsG,OAAA;EAAA,CN7BxCrG,CAAA,GM+BXC,CAAA,KN9BiB,qBAAbD,CAAA,CAAIuH,IAAA,IM+BpBxH,CAAA,CAAQgH,gBAAA,GAAmB9G,CAAA,EAC3BA,CAAA,CAAasH,IAAA,CAAK,UAAAvH,CAAA;IAChBD,CAAA,CAAQ0H,MAAA,GAASzH,CAAA;EAAA,MAGnBD,CAAA,CAAQ0H,MAAA,GAASxH,CAAA;AAAA;AAIrB,SAAS0H,EAAsB5H,CAAA;EAAA,OACzBA,CAAA,CAAQ2G,kBAAA,CAAmBC,OAAA,CAAQvG,MAAA,GAAS,KAC5CL,CAAA,CAAQ2G,kBAAA,CAAmBE,QAAA,CAASxG,MAAA,GAAS;AAAA;AAInD,SAASkH,EAAoBvH,CAAA,EAASC,CAAA,EAAMC,CAAA;EAC1CF,CAAA,CAAQ2G,kBAAA,CAAmB1G,CAAA,EAAM4H,IAAA,CAAK3H,CAAA,GASxC,UAA0BF,CAAA;IAAA,KACnBA,CAAA,CAAQyG,YAAA,IAAgBmB,CAAA,CAAqB5H,CAAA,GAAU;MAAA,IAGpDC,CAAA,GAAa,SAAA6H,CAAA7H,CAAA;UACjBD,CAAA,CAAQ2G,kBAAA,CAAmB1G,CAAA,CAAOuC,IAAA,EAAMuD,OAAA,CAAQ,UAAA/F,CAAA;YAC1CC,CAAA,CAAO6E,IAAA,IAAQ9E,CAAA,CAAI8E,IAAA,IACrB9E,CAAA,CAAIqH,EAAA,CAAGpH,CAAA,CAAOgC,IAAA;UAAA;QAAA;QAKd/B,CAAA,GAAOF,CAAA,CAAQuG,MAAA,CAAO7D,YAAA;MACxB1C,CAAA,CAAQgH,gBAAA,GAEVhH,CAAA,CAAQgH,gBAAA,CAAiBQ,IAAA,CAAK;QAC5BxH,CAAA,CAAQyG,YAAA,IAAe,GACvBzG,CAAA,CAAQuG,MAAA,CAAOpE,SAAA,CACbnC,CAAA,CAAQ0H,MAAA,EACRzH,CAAA,EACAC,CAAA;MAAA,MAIJF,CAAA,CAAQyG,YAAA,IAAe,GACvBzG,CAAA,CAAQuG,MAAA,CAAOpE,SAAA,CACbnC,CAAA,CAAQ0H,MAAA,EACRzH,CAAA,EACAC,CAAA;IAAA;EAAA,CApCN,CAAgBF,CAAA;AAAA;AAGlB,SAASsH,EAAuBtH,CAAA,EAASC,CAAA,EAAMC,CAAA;EAC7CF,CAAA,CAAQ2G,kBAAA,CAAmB1G,CAAA,IAAQD,CAAA,CAAQ2G,kBAAA,CAAmB1G,CAAA,EAAM6F,MAAA,CAAO,UAAA9F,CAAA;IAAA,OAAKA,CAAA,KAAME,CAAA;EAAA,IAsCxF,UAAyBF,CAAA;IAAA,IACnBA,CAAA,CAAQyG,YAAA,KAAiBmB,CAAA,CAAqB5H,CAAA,GAAU;MAE1DA,CAAA,CAAQyG,YAAA,IAAe;MAAA,IACjBxG,CAAA,GAAOD,CAAA,CAAQuG,MAAA,CAAO7D,YAAA;MAC5B1C,CAAA,CAAQuG,MAAA,CAAOpE,SAAA,CACbnC,CAAA,CAAQ0H,MAAA,EACR,MACAzH,CAAA;IAAA;EAAA,CA7CJ,CAAeD,CAAA;AAAA;AAAA,IC9KX+H,CAAA;EAAA,SAAA7H,EACSD,CAAA,EAASE,CAAA;IAAA,IAAAG,CAAA;IAAAN,CAAA,OAAAE,CAAA,QACf8H,QAAA,GAAW/H,CAAA,OACXgI,QAAA,GAAW9H,CAAA,OAEX+H,QAAA,IAAW,QACXC,MAAA,IAAS,QACTtD,KAAA,GAAQ1D,CAAA,SAERiH,WAAA,IAAc,QACdC,QAAA,IAAW,QAGXC,UAAA,GAAa,SACbC,UAAA,GAAa,SACbC,UAAA,GAAa,SACbC,mBAAA,GAAsB,qBACtBC,gBAAA,IAAmB,QACnBC,YAAA,GAAAC,CAAA,CAAAC,CAAA,CAAAC,IAAA,CAAe,SAAA9I,EAAA;MAAA,OAAA6I,CAAA,CAAAE,IAAA,WAAA/I,CAAA;QAAA,iBAAAA,CAAA,CAAAgJ,IAAA,GAAAhJ,CAAA,CAAAyD,IAAA;UAAA;UAAA;YAAA,OAAAzD,CAAA,CAAAiJ,IAAA;QAAA;MAAA,GAAAjJ,CAAA;IAAA;IAAA,IAEdQ,CAAA;MAAA,IAAAR,CAAA,GAAA4I,CAAA,CAAAC,CAAA,CAAAC,IAAA,CAAW,SAAA9I,EAAA;QAAA,OAAA6I,CAAA,CAAAE,IAAA,WAAA/I,CAAA;UAAA,iBAAAA,CAAA,CAAAgJ,IAAA,GAAAhJ,CAAA,CAAAyD,IAAA;YAAA;cAAA,OAAAzD,CAAA,CAAAkJ,MAAA,WAAY5I,CAAA,CAAK6I,GAAA;YAAA;YAAA;cAAA,OAAAnJ,CAAA,CAAAiJ,IAAA;UAAA;QAAA,GAAAjJ,CAAA;MAAA;MAAA;QAAA,OAAAA,CAAA,CAAAW,KAAA,OAAAP,SAAA;MAAA;IAAA;IAE9BX,CAAA,KACFC,MAAA,CAAOyE,gBAAA,CAAiB,gBAAgB3D,CAAA,GACxCd,MAAA,CAAOyE,gBAAA,CAAiB,UAAU3D,CAAA,QAE7B8H,UAAA,CAAWT,IAAA,CAAK,CAAC,gBAAgBrH,CAAA,SACjC8H,UAAA,CAAWT,IAAA,CAAK,CAAC,UAAUrH,CAAA;EAAA;EAAA,IAAAL,CAAA;EAAA,OAAAF,CAAA,CAAAC,CAAA;IAAA+C,GAAA;IAAAC,KAAA,EAIpC,SAAAkG,CAAA;MAAA,IAAApJ,CAAA;MAAA,IACM,KAAKkI,QAAA,EAAU,OAAOzG,OAAA,CAAQY,OAAA,EAAQ;MAAA,IACtC,KAAK8F,MAAA,EAAQ,OAAO1G,OAAA,CAAQY,OAAA,EAAQ;MAAA,IAGpC,KAAK+F,WAAA,cACFC,QAAA,IAAW,GACT5G,OAAA,CAAQY,OAAA,EAAQ;MAAA,KAEpB+F,WAAA,IAAc;MAAA,IAEfnI,CAAA,IAAe;QAGbC,CAAA,GAAgB,SAAAmJ,CAACnJ,CAAA;UACD,aAAhBA,CAAA,CAAIoJ,OAAA,IAAwBpJ,CAAA,CAAI2E,KAAA,KAAU7E,CAAA,CAAK6E,KAAA,KAG9B,YAAf3E,CAAA,CAAIqJ,MAAA,IAEFrJ,CAAA,CAAI2E,KAAA,GAAQ7E,CAAA,CAAK6E,KAAA,KAEnB5E,CAAA,IAAe,IAIA,WAAfC,CAAA,CAAIqJ,MAAA,KAENtJ,CAAA,IAAe;QAAA;MAAA,YAIhB+H,QAAA,CAAS7D,gBAAA,CAAiB,YAAYjE,CAAA,GAEpCsJ,CAAA,CAAa,MAAM,SACvBhC,IAAA,CAAK;QAAA,OAAMhG,CAAA,CAAMxB,CAAA,CAAKiI,QAAA,CAASwB,YAAA;MAAA,GAC/BjC,IAAA,CAAK;QAAA,OACAvH,CAAA,GAAqBwB,OAAA,CAAQa,MAAA,CAAO,IAAIkC,KAAA,MAChCgF,CAAA,CAAaxJ,CAAA,EAAM;MAAA,GAEhCwH,IAAA,CAAK;QAAA,OAAMhG,CAAA,CAAMxB,CAAA,CAAKiI,QAAA,CAASwB,YAAA;MAAA,GAC/BjC,IAAA,CAAK;QAAA,OACAvH,CAAA,GAAqBwB,OAAA,CAAQa,MAAA,CAAO,IAAIkC,KAAA,MAChCgF,CAAA,CAAaxJ,CAAA;MAAA,GAE1BwH,IAAA,CAAK;QAAA,OAoHL,UAAmBxH,CAAA;UACxBA,CAAA,CAAckI,QAAA,IAAW;UAAA,IAEnBjI,CAAA,GAAmB,SAAAyJ,CAAAzJ,CAAA;YACH,aAAhBA,CAAA,CAAIqJ,OAAA,IAAuC,YAAfrJ,CAAA,CAAIsJ,MAAA,IAClCC,CAAA,CAAaxJ,CAAA,EAAe,SAGV,aAAhBC,CAAA,CAAIqJ,OAAA,IAAuC,WAAfrJ,CAAA,CAAIsJ,MAAA,IAAsBvJ,CAAA,CAAc0I,gBAAA,KAOtE1I,CAAA,CAAc0I,gBAAA,IAAmB,GACjC1I,CAAA,CAAcyI,mBAAA,IACde,CAAA,CAAaxJ,CAAA,EAAe;UAAA;UAAA,OAGhCA,CAAA,CAAcgI,QAAA,CAAS7D,gBAAA,CAAiB,YAAYlE,CAAA,GACpDD,CAAA,CAAcuI,UAAA,CAAWV,IAAA,CAAK5H,CAAA,GACvBuJ,CAAA,CAAaxJ,CAAA,EAAe;QAAA,CA1InB,CAASA,CAAA;MAAA,GACpBwH,IAAA,CAAK;QAAA,QAAM;MAAA,GAAAG,KAAA,CACL;QAAA,QAAM;MAAA,GACZH,IAAA,CAAK,UAAAvH,CAAA;QAAA,OACJD,CAAA,CAAKgI,QAAA,CAAShD,mBAAA,CAAoB,YAAY9E,CAAA,GAC9CF,CAAA,CAAKoI,WAAA,IAAc,IACdnI,CAAA,IAAWD,CAAA,CAAKqI,QAAA,IACnBrI,CAAA,CAAKqI,QAAA,IAAW,GACTrI,CAAA,CAAK2J,SAAA,MACA1J,CAAA;MAAA;IAAA;EAAA;IAAAgD,GAAA;IAAAC,KAAA,EAIpB,SAAA0G,CAAA;MA2CF,IAA+B5J,CAAA;MAAA,OAzCxB,KAAK6J,uBAAA,UAEDA,uBAAA,IAuCoB7J,CAAA,GAvC2B,MAwCtCkI,QAAA,GAAiBzG,OAAA,CAAQY,OAAA,KAEpC,IAAIZ,OAAA,CAAQ,UAAAxB,CAAA;QAAA,IACbC,CAAA,IAAW;QAAA,SAENC,EAAA;UAEHD,CAAA,KAGJA,CAAA,IAAW,GACX4J,aAAA,CAAcxJ,CAAA,GACdN,CAAA,CAAcgI,QAAA,CAAShD,mBAAA,CAAoB,YAAYxE,CAAA,GACvDP,CAAA,EAAQ;QAAA;QAIVD,CAAA,CAAc2J,SAAA,GAAYnC,IAAA,CAAK;UACzBxH,CAAA,CAAckI,QAAA,IAChB/H,CAAA;QAAA;QAAA,IAKEG,CAAA,GAAWyJ,WAAA,CAAY;UAE3B/J,CAAA,CAAc2J,SAAA,GAAYnC,IAAA,CAAK;YACzBxH,CAAA,CAAckI,QAAA,IAChB/H,CAAA;UAAA;QAAA,GAGHH,CAAA,CAAciI,QAAA,CAAS+B,gBAAA;QAC1BhK,CAAA,CAAcwI,UAAA,CAAWX,IAAA,CAAKvH,CAAA;QAAA,IAGxBE,CAAA,GAAoB,SAAAyJ,CAAAhK,CAAA;UACJ,aAAhBA,CAAA,CAAIqJ,OAAA,IAAuC,YAAfrJ,CAAA,CAAIsJ,MAAA,IAClCvJ,CAAA,CAAc2J,SAAA,GAAYnC,IAAA,CAAK;YACzBxH,CAAA,CAAckI,QAAA,IAAU/H,CAAA;UAAA;QAAA;QAIlCH,CAAA,CAAcgI,QAAA,CAAS7D,gBAAA,CAAiB,YAAY3D,CAAA,GACpDR,CAAA,CAAcuI,UAAA,CAAWV,IAAA,CAAKrH,CAAA;MAAA,KAjFvB,KAAKqJ,uBAAA;IAAA;EAAA;IAAA5G,GAAA;IAAAS,GAAA,WAAAA,CAAA;MAAA,OASL,KAAK+E,mBAAA;IAAA;IAAA5F,GAAA,EANd,SAAA4F,CAAiBzI,CAAA;MAAA,KACVyI,mBAAA,GAAsBzI,CAAA;IAAA;EAAA;IAAAiD,GAAA;IAAAS,GAAA,WAAAA,CAAA;MAAA,OAcpB,KAAKiF,YAAA;IAAA;IAAA9F,GAAA,EANd,SAAA8F,CAAiB3I,CAAA;MAAA,KACV2I,YAAA,GAAe3I,CAAA;IAAA;EAAA;IAAAiD,GAAA;IAAAC,KAAA,GAAA/C,CAAA,GAAAyI,CAAA,CAAAC,CAAA,CAAAC,IAAA,CAQtB,SAAA9I,EAAA;MAAA,IAAAC,CAAA;MAAA,OAAA4I,CAAA,CAAAE,IAAA,WAAA/I,CAAA;QAAA,iBAAAA,CAAA,CAAAgJ,IAAA,GAAAhJ,CAAA,CAAAyD,IAAA;UAAA;YAAA,KACM,KAAK0E,MAAA;cAAAnI,CAAA,CAAAyD,IAAA;cAAA;YAAA;YAAA,OAAAzD,CAAA,CAAAkJ,MAAA;UAAA;YAAA,YACJf,MAAA,IAAS,GAAAnI,CAAA,CAAAyD,IAAA,MAER,KAAKyG,WAAA;UAAA;YAAA,YACN3B,UAAA,CAAWxC,OAAA,CAAQ,UAAA/F,CAAA;cAAA,OAAYC,CAAA,CAAK+H,QAAA,CAAShD,mBAAA,CAAoB,YAAYhF,CAAA;YAAA,SAC7EwI,UAAA,CAAWzC,OAAA,CAAQ,UAAA/F,CAAA;cAAA,OAAY8J,aAAA,CAAc9J,CAAA;YAAA,SAC7CsI,UAAA,CAAWvC,OAAA,CAAQ,UAAA/F,CAAA;cAClBP,CAAA,IACFC,MAAA,CAAOsF,mBAAA,CAAoBhF,CAAA,CAAI,IAAIA,CAAA,CAAI;YAAA,IAAAA,CAAA,CAAAkJ,MAAA,WAGpCM,CAAA,CAAa,MAAM;UAAA;UAAA;YAAA,OAAAxJ,CAAA,CAAAiJ,IAAA;QAAA;MAAA,GAAAjJ,CAAA;IAAA;MAAA,OAAAG,CAAA,CAAAQ,KAAA,OAAAP,SAAA;IAAA;EAAA,KAAAF,CAAA;AAAA;AAuD9B,SAASsJ,EAAcxJ,CAAA,EAAeC,CAAA;EAAA,IAC9BC,CAAA,GAAU;IACdoJ,OAAA,EAAS;IACTC,MAAA,EAAAtJ,CAAA;IACA4E,KAAA,EAAO7E,CAAA,CAAc6E;EAAA;EAAA,OAEhB7E,CAAA,CAAcgI,QAAA,CAASmC,YAAA,CAAajK,CAAA;AAAA;AC9LtC,IAAMkK,CAAA,GAAa,SAAAC,CAAArK,CAAA;EAAA,IACxBC,CAAA,GAAAD,CAAA,CAAAwC,IAAA;IACAtC,CAAA,GAAAF,CAAA,CAAA0E,WAAA;IACAvE,CAAA,GAAAH,CAAA,CAAAgK,gBAAA;IACA1J,CAAA,GAAAN,CAAA,CAAAyJ,YAAA;IACAjJ,CAAA,GAAAR,CAAA,CAAAsK,aAAA;IACApF,CAAA,GAAAlF,CAAA,CAAAuK,SAAA;IACAC,CAAA,GAAAxK,CAAA,CAAAyK,KAAA;IACAC,CAAA,GAAA1K,CAAA,CAAA2K,KAAA;IACAC,CAAA,GAAA5K,CAAA,CAAA6K,KAAA;IACAC,CAAA,GAAA9K,CAAA,CAAA+K,MAAA;IAEMpL,CAAA,GAAU,IAAI0G,CAAA,CAAenG,CAAA,EAAa;MAAEsC,IAAA,EAAAvC;IAAA;IAC5CR,CAAA,GD6MD,UAA+BO,CAAA,EAASC,CAAA;MAAA,IACzCD,CAAA,CAAQgL,cAAA,QACJ,IAAIxG,KAAA,CAAM;MAAA,IAGZtE,CAAA,GAAU,IAAI6H,CAAA,CAAe/H,CAAA,EAASC,CAAA;MAAA,OAC5CD,CAAA,CAAQ+G,YAAA,CAAac,IAAA,CAAAe,CAAA,CAAAC,CAAA,CAAAC,IAAA,CAAK,SAAA9I,EAAA;QAAA,OAAA6I,CAAA,CAAAE,IAAA,WAAA/I,CAAA;UAAA,iBAAAA,CAAA,CAAAgJ,IAAA,GAAAhJ,CAAA,CAAAyD,IAAA;YAAA;cAAA,OAAAzD,CAAA,CAAAkJ,MAAA,WAAYhJ,CAAA,CAAQiJ,GAAA;YAAA;YAAA;cAAA,OAAAnJ,CAAA,CAAAiJ,IAAA;UAAA;QAAA,GAAAjJ,CAAA;MAAA,MAE9CA,CAAA,CAAQgL,cAAA,GAAiB9K,CAAA,EAClBA,CAAA;IAAA,CCtNS,CAAqBP,CAAA,EAAS;MAAEqK,gBAAA,EAAA7J,CAAA;MAAkBsJ,YAAA,EAAAnJ;IAAA;IAC5DV,CAAA,GAAW;EAGjBA,CAAA,CAASH,CAAA,CAAQoF,KAAA,KAAS;EAAA,IAEtB/E,CAAA,IAAS;IACTC,CAAA,IAAU;IAERc,CAAA,GAAW,SAAAqH,CAAA;MAAA,OAAMpI,CAAA;IAAA;EAEvBL,CAAA,CAAQwL,eAAA,GAAkBzD,IAAA,CAAK;IAC7B1H,CAAA,IAAS;EAAA,IAGXH,CAAA,CAAQwE,gBAAA,CAAiB,WAAW,UAAAnE,CAAA;IAAA,IAAAC,CAAA,GAAAiL,CAAA,CAAAlL,CAAA;MAAEE,CAAA,GAAAD,CAAA;MAAME,CAAA,GAAAF,CAAA;IAAA,QAClCC,CAAA;MAAA,KACD;QACHN,CAAA,CAASO,CAAA,KAAM;QAAA;MAAA,KAEZ;QAAA,OACIP,CAAA,CAASO,CAAA;QAAA;MAAA,KAEb;QACHa,CAAA,CAAKb,CAAA;QAAA;MAAA,KAEF;QACHc,CAAA,CAAOd,CAAA;QAAA;MAAA,KAEJ;QACH+E,CAAA,CAAUiG,MAAA;QAAA;MAAA,KAEP;QACHjG,CAAA,CAAUkG,QAAA;QAAA;MAAA,KAEP;QACHZ,CAAA,EAAM;QAAA;MAAA,KAEH;QACHE,CAAA,EAAM;QAAA;MAAA,KAEH;QACHE,CAAA,EAAM;QAAA;MAAA,KAEH;QACHE,CAAA,EAAO;IAAA;EAAA;EAAA,IAaP9J,CAAA,GAAO,SAAAqK,CAAA;MAAA,IAACrL,CAAA,GAAAI,SAAA,CAAAC,MAAA,mBAAAD,SAAA,MAAAA,SAAA,MAAKX,CAAA,CAAQoF,KAAA;MACzBjF,CAAA,CAASI,CAAA,KAAM;MAAA,IACTC,CAAA,GAASqL,MAAA,CAAOC,MAAA,CAAO3L,CAAA,EAAU4L,KAAA,CAAM,UAAAxL,CAAA;QAAA,OAAKA,CAAA;MAAA;MAAA,CAC7CD,CAAA,IAAWE,CAAA,KACdF,CAAA,IAAU,GACNc,CAAA,MACFqE,CAAA,CAAUiG,MAAA,IACN3K,CAAA,IAAeU,CAAA,CAAK,eAExBA,CAAA,CAAK;IAAA;IAKLD,CAAA,GAAS,SAAAwK,CAAA;MAAA,IAACzL,CAAA,GAAAI,SAAA,CAAAC,MAAA,mBAAAD,SAAA,MAAAA,SAAA,MAAKX,CAAA,CAAQoF,KAAA;MAC3BjF,CAAA,CAASI,CAAA,KAAM;MAAA,IACTC,CAAA,GAAWqL,MAAA,CAAOC,MAAA,CAAO3L,CAAA,EAAU8L,IAAA,CAAK,UAAA1L,CAAA;QAAA,QAAMA,CAAA;MAAA;MAChDD,CAAA,IAAWE,CAAA,KACbF,CAAA,IAAU,GACNc,CAAA,MACFqE,CAAA,CAAUkG,QAAA,IACN5K,CAAA,IAAeU,CAAA,CAAK,iBAExBA,CAAA,CAAK;IAAA;EAMXzB,CAAA,CAAQkM,WAAA,GAAA/C,CAAA,CAAAC,CAAA,CAAAC,IAAA,CAAc,SAAA9I,EAAA;IAAA,OAAA6I,CAAA,CAAAE,IAAA,WAAA/I,CAAA;MAAA,iBAAAA,CAAA,CAAAgJ,IAAA,GAAAhJ,CAAA,CAAAyD,IAAA;QAAA;UAAA,OAAAzD,CAAA,CAAAyD,IAAA,MAAkBhE,CAAA,CAAQ0J,GAAA;QAAA;UAAA,OAAAnJ,CAAA,CAAAkJ,MAAA,WAAAlJ,CAAA,CAAA4L,IAAA;QAAA;QAAA;UAAA,OAAA5L,CAAA,CAAAiJ,IAAA;MAAA;IAAA,GAAAjJ,CAAA;EAAA,KAChDP,CAAA,CAAQyK,WAAA,GAAAtB,CAAA,CAAAC,CAAA,CAAAC,IAAA,CAAc,SAAA9I,EAAA;IAAA,OAAA6I,CAAA,CAAAE,IAAA,WAAA/I,CAAA;MAAA,iBAAAA,CAAA,CAAAgJ,IAAA,GAAAhJ,CAAA,CAAAyD,IAAA;QAAA;UAAA,OAAAzD,CAAA,CAAAyD,IAAA,MAAkBvC,CAAA,CAAK;QAAA;UAAA,OAAAlB,CAAA,CAAAkJ,MAAA,WAAAlJ,CAAA,CAAA4L,IAAA;QAAA;QAAA;UAAA,OAAA5L,CAAA,CAAAiJ,IAAA;MAAA;IAAA,GAAAjJ,CAAA;EAAA;EAAA,IAEvCkB,CAAA;MAAA,IAAAlB,CAAA,GAAA4I,CAAA,CAAAC,CAAA,CAAAC,IAAA,CAAO,SAAA9I,EAAMC,CAAA;QAAA,OAAA4I,CAAA,CAAAE,IAAA,WAAA/I,CAAA;UAAA,iBAAAA,CAAA,CAAAgJ,IAAA,GAAAhJ,CAAA,CAAAyD,IAAA;YAAA;cAAA,OAAAzD,CAAA,CAAAkJ,MAAA,WAAWvJ,CAAA,CAAQyC,WAAA,CAAY,CAACnC,CAAA,EAASR,CAAA,CAAQoF,KAAA;YAAA;YAAA;cAAA,OAAA7E,CAAA,CAAAiJ,IAAA;UAAA;QAAA,GAAAjJ,CAAA;MAAA;MAAA,iBAAAC,CAAA;QAAA,OAAAD,CAAA,CAAAW,KAAA,OAAAP,SAAA;MAAA;IAAA;IAE9De,CAAA;MAAA,IAAAnB,CAAA,GAAA4I,CAAA,CAAAC,CAAA,CAAAC,IAAA,CAAQ,SAAA9I,EAAA;QAAA,OAAA6I,CAAA,CAAAE,IAAA,WAAA/I,CAAA;UAAA,iBAAAA,CAAA,CAAAgJ,IAAA,GAAAhJ,CAAA,CAAAyD,IAAA;YAAA;cAAA,OAAAzD,CAAA,CAAAyD,IAAA,MACNhE,CAAA,CAAQ0J,GAAA;YAAA;cAAA,OAAAnJ,CAAA,CAAAyD,IAAA,MACR9D,CAAA,CAAQuC,KAAA;YAAA;YAAA;cAAA,OAAAlC,CAAA,CAAAiJ,IAAA;UAAA;QAAA,GAAAjJ,CAAA;MAAA;MAAA;QAAA,OAAAA,CAAA,CAAAW,KAAA,OAAAP,SAAA;MAAA;IAAA;EAAA,OAIhBc,CAAA,CAAK,aAEE;IAAEgB,KAAA,EAAAf,CAAA;IAAO0K,IAAA,EAAA3K,CAAA;IAAMgH,QAAA,EAAArH,CAAA;IAAUwK,IAAA,EAAArK,CAAA;IAAMyK,MAAA,EAAAxK,CAAA;IAAQ6K,SAAA,EA5C5B,SAAAA,CAAA;MAAA,OAAM/L,CAAA;IAAA;IA4CiCgM,UAAA,EAhDtC,SAAAA,CAAA/L,CAAA;MACjBD,CAAA,GAAUC,CAAA;IAAA;EAAA;AAAA;AAAA,SAAAgM,EAAAhM,CAAA;EAAA,IAAAC,CAAA;IAAA,0BAAAgM,OAAA,KAAAA,OAAA,CAAAC,SAAA;IAAA,IAAAD,OAAA,CAAAC,SAAA,CAAAC,IAAA;IAAA,yBAAAC,KAAA;IAAA;MAAA,OAAAC,OAAA,CAAAC,SAAA,CAAAC,OAAA,CAAAC,IAAA,CAAAP,OAAA,CAAAC,SAAA,CAAAG,OAAA;IAAA,SAAArM,CAAA;MAAA;IAAA;EAAA;EAAA;IAAA,IAAAE,CAAA;MAAAC,CAAA,GAAAK,CAAA,CAAAR,CAAA;IAAA,IAAAC,CAAA;MAAA,IAAAiF,CAAA,GAAA1E,CAAA,OAAAiM,WAAA;MAAAvM,CAAA,GAAA+L,OAAA,CAAAC,SAAA,CAAA/L,CAAA,EAAAC,SAAA,EAAA8E,CAAA;IAAA,OAAAhF,CAAA,GAAAC,CAAA,CAAAQ,KAAA,OAAAP,SAAA;IAAA,OAAAE,CAAA,OAAAJ,CAAA;EAAA;AAAA;AAAA,IC7CRwM,CAAA,aAAApM,CAAA;EAAAH,CAAA,CAAAqK,CAAA,EAAkBtF,CAAA;EAAA,IAAA1E,CAAA,GAAAwL,CAAA,CAAAxB,CAAA;EAAA,SAAAA,EASTvK,CAAA;IAAA,IAAAE,CAAA;IAAA,IAAAH,CAAA,OAAAwK,CAAA,IAAArK,CAAA,GAAAK,CAAA,CAAAgM,IAAA,OACLvM,CAAA,GAOD0M,KAAA,GAAQ;MACXtB,IAAA,GAAM;MACNuB,OAAA,GAAU,IAAI9L,IAAA;MACd+L,UAAA,GAAa,IAAI/L,IAAA;MACjBgM,QAAA,EAAU;MACVC,QAAA,EAAU;MACVC,SAAA,EAAW;MACXC,KAAA,EAAO;MACPC,KAAA,EAAO;IAAA,GAAA/M,CAAA,CAQJgN,GAAA,GAAM,MAAAhN,CAAA,CAONiN,WAAA,IAAc,GAAAjN,CAAA,CAEdkN,YAAA,GAAe,IAGhBpN,CAAA,CAAMqN,QAAA,GAAW,KAAKrN,CAAA,CAAMsN,QAAA,GAAW,SACnC,IAAI/I,KAAA,CAAM;IAAA,OAIdvE,CAAA,CAAMqN,QAAA,GAAW,IAAAnN,CAAA,CACdqN,SAAA,GAAYzN,CAAA,CAAUE,CAAA,CAAMwN,QAAA,EAAUxN,CAAA,CAAMqN,QAAA,IAGxCrN,CAAA,CAAMsN,QAAA,GAAW,IAAApN,CAAA,CACrBqN,SAAA,GAAY3M,CAAA,CAAUZ,CAAA,CAAMwN,QAAA,EAAUxN,CAAA,CAAMsN,QAAA,IAAApN,CAAA,CAI5CqN,SAAA,GAAYvN,CAAA,CAAMwN,QAAA,EAIrBxN,CAAA,CAAMyN,cAAA,GAAiB,IAAAvN,CAAA,CACpBwN,WAAA,GAAc9M,CAAA,CAAUV,CAAA,CAAKyN,YAAA,CAAaC,IAAA,CAAA3N,CAAA,CAAAC,CAAA,IAAYF,CAAA,CAAMyN,cAAA,IAAAvN,CAAA,CAE5DwN,WAAA,GAAcxN,CAAA,CAAKyN,YAAA,CAAaC,IAAA,CAAA3N,CAAA,CAAAC,CAAA,IAIlCF,CAAA,CAAM6N,YAAA,KAAgB7N,CAAA,CAAM8N,aAAA,KAAA5N,CAAA,CAC1BwM,KAAA,CAAMtB,IAAA,IAAO,IAAAlL,CAAA,CAIf6N,gBAAA,GAAmB7N,CAAA,CAAK6N,gBAAA,CAAiBH,IAAA,CAAA3N,CAAA,CAAAC,CAAA,IAAAA,CAAA,CACzCsK,KAAA,GAAQtK,CAAA,CAAKsK,KAAA,CAAMoD,IAAA,CAAA3N,CAAA,CAAAC,CAAA,IAAAA,CAAA,CACnBwK,KAAA,GAAQxK,CAAA,CAAKwK,KAAA,CAAMkD,IAAA,CAAA3N,CAAA,CAAAC,CAAA,IAAAA,CAAA,CACnB0K,KAAA,GAAQ1K,CAAA,CAAK0K,KAAA,CAAMgD,IAAA,CAAA3N,CAAA,CAAAC,CAAA,IAAAA,CAAA,CACnB4K,MAAA,GAAS5K,CAAA,CAAK4K,MAAA,CAAO8C,IAAA,CAAA3N,CAAA,CAAAC,CAAA,IAAAA,CAAA,CACrB8N,MAAA,GAAS9N,CAAA,CAAK8N,MAAA,CAAOJ,IAAA,CAAA3N,CAAA,CAAAC,CAAA,IAAAA,CAAA,CACrB+N,gBAAA,GAAmB/N,CAAA,CAAK+N,gBAAA,CAAiBL,IAAA,CAAA3N,CAAA,CAAAC,CAAA,IAAAA,CAAA,CACzCgO,cAAA,GAAiBhO,CAAA,CAAKgO,cAAA,CAAeN,IAAA,CAAA3N,CAAA,CAAAC,CAAA,IAAAA,CAAA,CACrCiO,iBAAA,GAAoBjO,CAAA,CAAKiO,iBAAA,CAAkBP,IAAA,CAAA3N,CAAA,CAAAC,CAAA,IAAAA,CAAA,CAC3CkO,eAAA,GAAkBlO,CAAA,CAAKkO,eAAA,CAAgBR,IAAA,CAAA3N,CAAA,CAAAC,CAAA,IAAAA,CAAA,CACvCmO,gBAAA,GAAmBnO,CAAA,CAAKmO,gBAAA,CAAiBT,IAAA,CAAA3N,CAAA,CAAAC,CAAA,IAAAA,CAAA,CACzCoO,kBAAA,GAAqBpO,CAAA,CAAKoO,kBAAA,CAAmBV,IAAA,CAAA3N,CAAA,CAAAC,CAAA,IAAAA,CAAA;EAAA;EAAA,OAAAF,CAAA,CAAAuK,CAAA;IAAAvH,GAAA;IAAAC,KAAA,EASpD,SAAA2K,CAAA;MAAA,IAAA7N,CAAA,GAC0C,KAAKwO,KAAA;QAArCvO,CAAA,GAAAD,CAAA,CAAA8N,YAAA;QAAc5N,CAAA,GAAAF,CAAA,CAAA+N,aAAA;MAAA,KAGjBU,gBAAA,IAEDvO,CAAA,KACAD,CAAA,QACGwK,KAAA,UAEAiE,WAAA;IAAA;EAAA;IAAAzL,GAAA;IAAAC,KAAA,EAIT,SAAAwL,CAAoB1O,CAAA;MAEbA,CAAA,CAAUsN,QAAA,KAAa,KAAKkB,KAAA,CAAMlB,QAAA,IAAa,KAAKkB,KAAA,CAAMlB,QAAA,GAAW,KACpE,KAAKE,SAAA,CAAU5M,MAAA,IAAQ,KAAK4M,SAAA,CAAU5M,MAAA,SACrC4M,SAAA,GAAYzN,CAAA,CAAU,KAAKyO,KAAA,CAAMf,QAAA,EAAU,KAAKe,KAAA,CAAMlB,QAAA,KAGxDtN,CAAA,CAAUuN,QAAA,KAAa,KAAKiB,KAAA,CAAMjB,QAAA,IAAa,KAAKiB,KAAA,CAAMjB,QAAA,GAAW,KACpE,KAAKC,SAAA,CAAU5M,MAAA,IAAQ,KAAK4M,SAAA,CAAU5M,MAAA,SACrC4M,SAAA,GAAY3M,CAAA,CAAU,KAAK2N,KAAA,CAAMf,QAAA,EAAU,KAAKe,KAAA,CAAMjB,QAAA,MAI1DvN,CAAA,CAAUuN,QAAA,IAAoC,MAAxB,KAAKiB,KAAA,CAAMjB,QAAA,IACjCvN,CAAA,CAAUsN,QAAA,IAAoC,MAAxB,KAAKkB,KAAA,CAAMlB,QAAA,MAE9B,KAAKE,SAAA,CAAU5M,MAAA,IAAQ,KAAK4M,SAAA,CAAU5M,MAAA,SACrC4M,SAAA,GAAY,KAAKgB,KAAA,CAAMf,QAAA,GAI1BzN,CAAA,CAAU0N,cAAA,KAAmB,KAAKc,KAAA,CAAMd,cAAA,UACrCiB,aAAA,SACAhB,WAAA,GAAc9M,CAAA,CAAU,KAAK+M,YAAA,CAAaC,IAAA,CAAK,OAAO,KAAKW,KAAA,CAAMd,cAAA,QACjEgB,WAAA,KAGH1O,CAAA,CAAU4O,OAAA,KAAY,KAAKJ,KAAA,CAAMI,OAAA,IAC/B,KAAKjC,KAAA,CAAMtB,IAAA,IAAM,KAAKV,KAAA,IAIxB3K,CAAA,CAAUoL,QAAA,KAAa,KAAKoD,KAAA,CAAMpD,QAAA,KAAU,KAAKiC,YAAA,CAAajC,QAAA,GAAW,KAAKoD,KAAA,CAAMpD,QAAA,GACpFpL,CAAA,CAAUmL,MAAA,KAAW,KAAKqD,KAAA,CAAMrD,MAAA,KAAQ,KAAKkC,YAAA,CAAalC,MAAA,GAAS,KAAKqD,KAAA,CAAMrD,MAAA;IAAA;EAAA;IAAAlI,GAAA;IAAAC,KAAA,EASpF,SAAAiI,CAAA;MAEE1K,YAAA,CAAa,KAAK0M,GAAA,QACbwB,aAAA,EAAc,IAEf,KAAKnB,SAAA,CAAU5M,MAAA,IAAQ,KAAK4M,SAAA,CAAU5M,MAAA,IAEtC,KAAKiO,OAAA,SACFA,OAAA,CAAQ3M,KAAA,GAAAyF,KAAA,CAAcmH,OAAA,CAAQC,KAAA;IAAA;EAAA;IAAA9L,GAAA;IAAAC,KAAA,EASvC,SAAA6L,CAAA;MAAA,OACuB,KAAKP,KAAA,CAAlBQ,QAAA,IACW;IAAA;EAAA;IAAA/L,GAAA;IAAAC,KAAA,EAOrB,SAAAA,CAAA;MAAA,IAAAlD,CAAA,GACyC,KAAKwO,KAAA;QAApCvO,CAAA,GAAAD,CAAA,CAAAiP,QAAA;QAAU/O,CAAA,GAAAF,CAAA,CAAAmL,MAAA;QAAQhL,CAAA,GAAAH,CAAA,CAAAoL,QAAA;MAAA,SACrBiC,YAAA,GAAe;QAAElC,MAAA,EAAAjL,CAAA;QAAQkL,QAAA,EAAAjL;MAAA,GAG1BF,CAAA,EAAU;QAAA,IAAAK,CAAA,GAORgL,MAAA,CAAO4D,MAAA,CAAO;YAChBxK,WAAA,EAAa;YACbsF,gBAAA,EAAkB;YAClBP,YAAA,EAAc;YACdhF,aAAA,EAAe;YACf6F,aAAA,GAAe;UAAA,IACD,MAAbrK,CAAA,GAAoB,KAAKA,CAAA;UAX1BO,CAAA,GAAAF,CAAA,CAAAkC,IAAA;UACA0C,CAAA,GAAA5E,CAAA,CAAAoE,WAAA;UACA8F,CAAA,GAAAlK,CAAA,CAAA0J,gBAAA;UACAU,CAAA,GAAApK,CAAA,CAAAmJ,YAAA;UACAmB,CAAA,GAAAtK,CAAA,CAAAgK,aAAA;QAAA,KASGuE,OAAA,GAAUzE,CAAA,CAAW;UACxB5H,IAAA,EAAAhC,CAAA;UACAkE,WAAA,EAAAQ,CAAA;UACA8E,gBAAA,EAAAQ,CAAA;UACAf,YAAA,EAAAiB,CAAA;UACAJ,aAAA,EAAAM,CAAA;UACAL,SAAA,EAAW,KAAK8C,YAAA;UAChB5C,KAAA,EAAO,KAAKA,KAAA;UACZE,KAAA,EAAO,KAAKA,KAAA;UACZE,KAAA,EAAO,KAAKA,KAAA;UACZE,MAAA,EAAQ,KAAKA;QAAA;MAAA;IAAA;EAAA;IAAA9H,GAAA;IAAAC,KAAA,EASnB,SAAA6H,CAAA;MAAA,IAAA/K,CAAA;MAAA,IAGOP,CAAA;QAAA,IAAAQ,CAAA,GAGyC,KAAKuO,KAAA;UAA3CtO,CAAA,GAAAD,CAAA,CAAAkP,OAAA;UAAShP,CAAA,GAAAF,CAAA,CAAAmP,MAAA;UAAQ9O,CAAA,GAAAL,CAAA,CAAAoP,OAAA;UAAS7O,CAAA,GAAAP,CAAA,CAAAqP,OAAA;QAC7B,KAAKlC,WAAA,KACRjN,CAAA,CAAO4F,OAAA,CAAQ,UAAA9F,CAAA;UACbC,CAAA,CAAQiE,gBAAA,CAAiBlE,CAAA,EAAGD,CAAA,CAAK2N,WAAA,EAAa;YAC5C2B,OAAA,EAAA9O,CAAA;YACA6O,OAAA,EAAA/O;UAAA;QAAA,SAGC8M,WAAA,IAAc;MAAA;IAAA;EAAA;IAAAnK,GAAA;IAAAC,KAAA,EAQvB,SAAAA,CAAA;MAAA,IAAAlD,CAAA;QAAeC,CAAA,GAAAG,SAAA,CAAAC,MAAA,mBAAAD,SAAA,OAAAA,SAAA;MAAA,IAGRX,CAAA;QAAA,IAAAS,CAAA,GAEyC,KAAKsO,KAAA;UAA3CrO,CAAA,GAAAD,CAAA,CAAAiP,OAAA;UAAS7O,CAAA,GAAAJ,CAAA,CAAAkP,MAAA;UAAQ5O,CAAA,GAAAN,CAAA,CAAAmP,OAAA;UAASnK,CAAA,GAAAhF,CAAA,CAAAoP,OAAA;QAAA,CAC9B,KAAKlC,WAAA,IAAenN,CAAA,MACtBK,CAAA,CAAOyF,OAAA,CAAQ,UAAA9F,CAAA;UACbE,CAAA,CAAQ6E,mBAAA,CAAoB/E,CAAA,EAAGD,CAAA,CAAK2N,WAAA,EAAa;YAC/C2B,OAAA,EAAApK,CAAA;YACAmK,OAAA,EAAA7O;UAAA;QAAA,SAGC4M,WAAA,IAAc;MAAA;IAAA;EAAA;IAAAnK,GAAA;IAAAC,KAAA,EASvB,SAAAA,CAAkBlD,CAAA;MAAA,IAAAC,CAAA;MAAA,KAIXsP,QAAA,CAAS,UAACvP,CAAA;QAAA,OAAe;UAC5BqL,IAAA,GAAOrL,CAAA,CAAUqL,IAAA;UACjByB,QAAA,EAAW9M,CAAA,CAAUqL,IAAA,GAA4CrL,CAAA,CAAU8M,QAAA,IAA7C,IAAIhM,IAAA,KAAUb,CAAA,CAAKuO,KAAA,CAAMI,OAAA;UACvD7B,QAAA,EAAU/M,CAAA,CAAUqL,IAAA,GAAOrL,CAAA,CAAU+M,QAAA,IAAa,IAAIjM,IAAA,KAAUd,CAAA,CAAU8M,QAAA,GAAW9M,CAAA,CAAU+M;QAAA;MAAA,GAC7F;QAAA,IAAA7M,CAAA,GACuCD,CAAA,CAAKuO,KAAA;UAAtCrO,CAAA,GAAAD,CAAA,CAAAkL,QAAA;UAAU9K,CAAA,GAAAJ,CAAA,CAAAiL,MAAA;UAAQ3K,CAAA,GAAAN,CAAA,CAAAsP,UAAA;QACTvP,CAAA,CAAK0M,KAAA,CAAdtB,IAAA,IAEF7K,CAAA,KAEFC,YAAA,CAAaR,CAAA,CAAKkN,GAAA,GAClBlN,CAAA,CAAKkN,GAAA,GAAM,MAEXlN,CAAA,CAAK0O,aAAA,KAGH1O,CAAA,CAAK4O,OAAA,GAEP5O,CAAA,CAAK4O,OAAA,CAAQxD,IAAA,KAEb/K,CAAA,CAAON,CAAA,MAGTC,CAAA,CAAKyO,WAAA,IACDzO,CAAA,CAAK4O,OAAA,GAEP5O,CAAA,CAAK4O,OAAA,CAAQpD,MAAA,KAEbtL,CAAA,CAASH,CAAA;MAAA;IAAA;EAAA;IAAAiD,GAAA;IAAAC,KAAA,EAWjB,SAAAlD,CAAcA,CAAA;MAAA,IAAAC,CAAA,GAC8B,KAAK0M,KAAA;QAAvCzM,CAAA,GAAAD,CAAA,CAAA+M,SAAA;QAAW7M,CAAA,GAAAF,CAAA,CAAAgN,KAAA;QAAO3M,CAAA,GAAAL,CAAA,CAAAiN,KAAA;QAAO1M,CAAA,GAAAP,CAAA,CAAAoL,IAAA;QAAAnG,CAAA,GACD,KAAKsJ,KAAA;QAA7BhE,CAAA,GAAAtF,CAAA,CAAA0J,OAAA;QAASlE,CAAA,GAAAxF,CAAA,CAAAsK,UAAA;MAAA,SAGZhC,SAAA,CAAUxN,CAAA,IAGXE,CAAA;QAAA,IAGW,gBAAXF,CAAA,CAAEwC,IAAA,EAAsB;UAAA,IAGtBxC,CAAA,CAAEiN,KAAA,KAAU9M,CAAA,IAASH,CAAA,CAAEkN,KAAA,KAAU5M,CAAA;UAAA,SAId,MAAZN,CAAA,CAAEiN,KAAA,SAA4C,MAAZjN,CAAA,CAAEkN,KAAA;UAAA,IAM/B,KAAKiB,cAAA,KAEP;QAAA;QAMhB1N,YAAA,CAAa,KAAK0M,GAAA,QACbA,GAAA,GAAM;QAAA,IAGLvC,CAAA,IAA8B,IAAI9J,IAAA,KAAS,KAAKsN,iBAAA;QAAA,CAGjD5N,CAAA,KAASkK,CAAA,KAAiBlK,CAAA,IAAQoK,CAAA,GAA6BJ,CAAA,UAC7DwD,gBAAA,CAAiBhO,CAAA,QAKnBuP,QAAA,CAAS;UACZ1C,UAAA,GAAa,IAAI/L,IAAA;UACjBmM,KAAA,EAAOjN,CAAA,CAAEiN,KAAA;UACTC,KAAA,EAAOlN,CAAA,CAAEkN;QAAA,IAKP1M,CAAA,IACGkK,CAAA,UAIAyC,GAAA,GAAMzM,UAAA,CAAW,KAAKsN,gBAAA,EAAkBxD,CAAA;MAAA;IAAA;EAAA;IAAAvH,GAAA;IAAAC,KAAA,EAQjD,SAAA0L,CAAA;MAAA,IAAO5O,CAAA,KAAAI,SAAA,CAAAC,MAAA,mBAAAD,SAAA,QAAAA,SAAA;MAELK,YAAA,CAAa,KAAK0M,GAAA,QACbA,GAAA,GAAM,WAGNuB,WAAA,SAGAa,QAAA,CAAS;QACZlE,IAAA,GAAM;QACNuB,OAAA,GAAU,IAAI9L,IAAA;QACd+L,UAAA,GAAa,IAAI/L,IAAA;QACjBkM,SAAA,EAAW;MAAA,IAGT,KAAK6B,OAAA,UAEFA,OAAA,CAAQ9C,UAAA,EAAW,KAEnB/L,CAAA,IAAU,KAAKwO,KAAA,CAAMS,QAAA,CAAS3E,aAAA,SAC5BuE,OAAA,CAAQhD,IAAA,CAAK;MAAA,IAKd5L,CAAA,GAAY,KAAKuO,KAAA,CAAjBI,OAAA;MAAA,KACHzB,GAAA,GAAMzM,UAAA,CAAW,KAAKsN,gBAAA,EAAkB/N,CAAA;IAAA;EAAA;IAAAgD,GAAA;IAAAC,KAAA,EAO/C,SAAA0L,CAAA;MAAA,IAAO5O,CAAA,GAAAI,SAAA,CAAAC,MAAA,mBAAAD,SAAA,OAAAA,SAAA;MAELK,YAAA,CAAa,KAAK0M,GAAA,QACbA,GAAA,GAAM,WAGNuB,WAAA,IAED,KAAK/B,KAAA,CAAMtB,IAAA,KACT,KAAKwD,OAAA,QAEFA,OAAA,CAAQpD,MAAA,UAER+C,KAAA,CAAMpD,QAAA,KAIX,KAAKyD,OAAA,UAEFA,OAAA,CAAQ9C,UAAA,EAAW,KAEnB/L,CAAA,IAAU,KAAKwO,KAAA,CAAMS,QAAA,CAAS3E,aAAA,SAC5BuE,OAAA,CAAQhD,IAAA,CAAK,gBAKjB0D,QAAA,CAAS;QACZlE,IAAA,GAAM;QACNuB,OAAA,GAAU,IAAI9L,IAAA;QACd+L,UAAA,GAAa,IAAI/L,IAAA;QACjBkM,SAAA,EAAW;MAAA;MAAA,IAIL/M,CAAA,GAAY,KAAKuO,KAAA,CAAjBI,OAAA;MAAA,KACHzB,GAAA,GAAMzM,UAAA,CAAW,KAAKsN,gBAAA,EAAkB/N,CAAA;IAAA;EAAA;IAAAgD,GAAA;IAAAC,KAAA,EAO/C,SAAA0L,CAAA;MAAA,IAAO5O,CAAA,GAAAI,SAAA,CAAAC,MAAA,mBAAAD,SAAA,OAAAA,SAAA;QAEGH,CAAA,GAAc,KAAK0M,KAAA,CAAnBK,SAAA;MACU,SAAd/M,CAAA,UAGC0O,aAAA,IAGLlO,YAAA,CAAa,KAAK0M,GAAA,QACbA,GAAA,GAAM,MAGP,KAAK0B,OAAA,KAEF7O,CAAA,IAAU,KAAKwO,KAAA,CAAMS,QAAA,CAAS3E,aAAA,SAC5BuE,OAAA,CAAQhD,IAAA,CAAK,eAKjB0D,QAAA,CAAS;QACZvC,SAAA,EAAW,KAAKkB,gBAAA;MAAA;IAAA;EAAA;IAAAjL,GAAA;IAAAC,KAAA,EAQpB,SAAAgL,CAAA;MAAA,IAAQlO,CAAA,GAAAI,SAAA,CAAAC,MAAA,mBAAAD,SAAA,OAAAA,SAAA;QAAAH,CAAA,GAEsB,KAAK0M,KAAA;QAAzBzM,CAAA,GAAAD,CAAA,CAAA+M,SAAA;QAAW7M,CAAA,GAAAF,CAAA,CAAAoL,IAAA;MACD,SAAdnL,CAAA,UAGCwO,WAAA,IAGD,KAAKG,OAAA,KAEF7O,CAAA,IAAU,KAAKwO,KAAA,CAAMS,QAAA,CAAS3E,aAAA,SAC5BuE,OAAA,CAAQhD,IAAA,CAAK,WAMjB1L,CAAA,UAEEgN,GAAA,GAAMzM,UAAA,CAAW,KAAKsN,gBAAA,EAAkB9N,CAAA,QAExCqP,QAAA,CAAS;QAAEvC,SAAA,EAAW;QAAMH,UAAA,GAAa,IAAI/L,IAAA;MAAA;IAAA;EAAA;IAAAmC,GAAA;IAAAC,KAAA,EAStD,SAAApC,CAAA;MAAA,IAAAd,CAAA,GACoC,KAAK2M,KAAA;QAA/B1M,CAAA,GAAAD,CAAA,CAAAgN,SAAA;QAAW9M,CAAA,GAAAF,CAAA,CAAA6M,UAAA;QACX1M,CAAA,GAAY,KAAKqO,KAAA,CAAjBI,OAAA;MAAA,IAGU,SAAd3O,CAAA,SACKA,CAAA,GAAY,IAAI,IAAIA,CAAA;MAAA,IAIvBK,CAAA,GAAWH,CAAA,KAAa,IAAIW,IAAA,KAAUZ,CAAA;MAAA,OACrCI,CAAA,GAAW,IAAI,IAAIA,CAAA;IAAA;EAAA;IAAA2C,GAAA;IAAAC,KAAA,EAQ5B,SAAAuM,CAAA;MAAA,IACUzP,CAAA,GAAY,KAAK2M,KAAA,CAAjBC,OAAA;MAAA,QACC,IAAI9L,IAAA,KAAUd,CAAA;IAAA;EAAA;IAAAiD,GAAA;IAAAC,KAAA,EAQzB,SAAA0J,CAAA;MAAA,OACuB,KAAKD,KAAA,CAAlBG,QAAA;IAAA;EAAA;IAAA7J,GAAA;IAAAC,KAAA,EASV,SAAA4J,CAAA;MAAA,IAAA9M,CAAA,GACuC,KAAK2M,KAAA;QAAlC1M,CAAA,GAAAD,CAAA,CAAAqL,IAAA;QAAMnL,CAAA,GAAAF,CAAA,CAAA8M,QAAA;QAAU3M,CAAA,GAAAH,CAAA,CAAA+M,QAAA;MAAA,OACpB9M,CAAA,IACQ,IAAIa,IAAA,KAAUZ,CAAA,GAAYC,CAAA,GAE7BA,CAAA;IAAA;EAAA;IAAA8C,GAAA;IAAAC,KAAA,EASX,SAAA6J,CAAA;MAAA,OACyB,KAAKJ,KAAA,CAApBE,UAAA;IAAA;EAAA;IAAA5J,GAAA;IAAAC,KAAA,EASV,SAAA2J,CAAA;MAAA,OACS,KAAKsB,cAAA,KAAmB,KAAKG,gBAAA;IAAA;EAAA;IAAArL,GAAA;IAAAC,KAAA,EAQtC,SAAAoL,CAAA;MAAA,OACmB,KAAK3B,KAAA,CAAdtB,IAAA;IAAA;EAAA;IAAApI,GAAA;IAAAC,KAAA,EASV,SAAAmI,CAAA;MAAA,QACS,KAAKwD,OAAA,IAAU,KAAKA,OAAA,CAAQ3G,QAAA;IAAA;EAAA,KAAAsC,CAAA;AAAA;AC9kBvC,SAASkF,EAAA;EAAA,IAAA1P,CAAA,GAAAI,SAAA,CAAAC,MAAA,mBAAAD,SAAA,MAAAA,SAAA,MAgBL;IAAAH,CAAA,GAAAD,CAAA,CAfF4O,OAAA;IAAA1O,CAAA,cAAAD,CAAA,GAAU,OAAAA,CAAA;IAAAE,CAAA,GAAAH,CAAA,CACVmP,OAAA;IAAA7O,CAAA,cAAAH,CAAA,GAAUP,CAAA,GAAAO,CAAA;IAAAK,CAAA,GAAAR,CAAA,CACVoP,MAAA;IAAAlK,CAAA,cAAA1E,CAAA,GAASV,CAAA,GAAAU,CAAA;IAAAsK,CAAA,GAAA9K,CAAA,CACTmL,MAAA;IAAAD,CAAA,cAAAJ,CAAA,GAAS,iBAAAA,CAAA;IAAAnL,CAAA,GAAAK,CAAA,CACToL,QAAA;IAAApK,CAAA,cAAArB,CAAA,GAAW,iBAAAA,CAAA;IAAAsB,CAAA,GAAAjB,CAAA,CACXyN,QAAA;IAAAvM,CAAA,cAAAD,CAAA,GAAW,iBAAAA,CAAA;IAAAE,CAAA,GAAAnB,CAAA,CACXsN,QAAA;IAAA9L,CAAA,cAAAL,CAAA,GAAW,IAAAA,CAAA;IAAAO,CAAA,GAAA1B,CAAA,CACXuN,QAAA;IAAA5L,CAAA,cAAAD,CAAA,GAAW,IAAAA,CAAA;IAAAiB,CAAA,GAAA3C,CAAA,CACX0N,cAAA;IAAA9J,CAAA,cAAAjB,CAAA,GAAiB,MAAAA,CAAA;IAAAmB,CAAA,GAAA9D,CAAA,CACjB8N,YAAA;IAAA1J,CAAA,cAAAN,CAAA,IAAAA,CAAA;IAAAS,CAAA,GAAAvE,CAAA,CACA+N,aAAA;IAAArI,CAAA,cAAAnB,CAAA,IAAAA,CAAA;IAAAoB,CAAA,GAAA3F,CAAA,CACAwP,UAAA;IAAAxJ,CAAA,cAAAL,CAAA,IAAAA,CAAA;IAAAM,CAAA,GAAAjG,CAAA,CACAsP,OAAA;IAAAjJ,CAAA,cAAAJ,CAAA,IAAAA,CAAA;IAAAkB,CAAA,GAAAnH,CAAA,CACAqP,OAAA;IAAApI,CAAA,cAAAE,CAAA,IAAAA,CAAA;IAAAS,CAAA,GAAA5H,CAAA,CACAiP,QAAA;IAAA1H,CAAA,cAAAK,CAAA,IAAAA,CAAA;IAEMN,CAAA,GAAckD,CAAA,EAAO;IACrBzC,CAAA,GAAOyC,CAAA,EAAO;IACdhB,CAAA,GAAUgB,CAAA,EAAQ,IAAI1J,IAAA;IACtBkL,CAAA,GAAYxB,CAAA,CAAO;IACnBkC,CAAA,GAAQlC,CAAA,CAAO;IACfkF,CAAA,GAAQlF,CAAA,CAAO;IACfmF,CAAA,GAAMnF,CAAA,CAAO;IACboF,CAAA,GAAapF,CAAA,CAAO;IACpBqF,CAAA,GAAWrF,CAAA,CAAO;IAClBsF,CAAA,GAAWtF,CAAA,CAAO;IAClBuF,CAAA,GAAYvF,CAAA,EAAO;IACnBwF,CAAA,GAAWxF,CAAA,CAAOtK,CAAA;IAClB+P,EAAA,GAAUzF,CAAA,CAAO;EAGnBjD,CAAA,MACe,MAAbA,CAAA,KAAmBA,CAAA,GAAW,KAClCA,CAAA,GAAW+D,MAAA,CAAO4D,MAAA,CAAO;IACvBxK,WAAA,EAAa;IACbsF,gBAAA,EAAkB;IAClBP,YAAA,EAAc;IACdhF,aAAA,EAAe;IACf6F,aAAA,GAAe;EAAA,GACd/C,CAAA;EAAA,IAIC2I,EAAA,GAAa1F,CAAA,CAAOU,CAAA;IACpBiF,EAAA,GAAe3F,CAAA,CAAOxJ,CAAA;IACtBoP,EAAA,GAAe5F,CAAA,CAAOtJ,CAAA;EAE5BwJ,CAAA,CAAU;IACRwF,EAAA,CAAWG,OAAA,GAAUnF,CAAA;EAAA,GACpB,CAACA,CAAA,IAEJR,CAAA,CAAU;IACRyF,EAAA,CAAaE,OAAA,GAAUrP,CAAA;EAAA,GACtB,CAACA,CAAA,IAEJ0J,CAAA,CAAU;IACR0F,EAAA,CAAaC,OAAA,GAAUnP,CAAA;EAAA,GACtB,CAACA,CAAA;EAAA,IAEEoP,EAAA,GAAuB1F,CAAA,CAAQ;MAAA,SAC1B5K,EAAcA,CAAA;QACrBoQ,EAAA,CAAaC,OAAA,CAAQrQ,CAAA;MAAA;MAAA,OAInBA,CAAA,CAAaY,MAAA,IAAQZ,CAAA,CAAaY,MAAA,IAGlCY,CAAA,GAAW,IACNzB,CAAA,CAAUC,CAAA,EAAcwB,CAAA,IAGtBG,CAAA,GAAW,IACbd,CAAA,CAAUb,CAAA,EAAc2B,CAAA,IAIxB3B,CAAA;IAAA,GAER,CAAC2B,CAAA,EAAUH,CAAA;IAOR+O,EAAA,GAAmB,SAAAvC,CAAAhO,CAAA;MAAA,IACjBC,CAAA,IAAY8H,CAAA,CAAKsI,OAAA;MACvBtI,CAAA,CAAKsI,OAAA,GAAUpQ,CAAA,EACXA,CAAA,IACE+F,CAAA,KAEFvF,YAAA,CAAakP,CAAA,CAAIU,OAAA,GACjBV,CAAA,CAAIU,OAAA,GAAU,MAEdG,EAAA,KAEFX,CAAA,CAASQ,OAAA,IAAY,IAAIvP,IAAA,KAAUkP,CAAA,CAASK,OAAA,EACxCJ,EAAA,CAAQI,OAAA,GAEVJ,EAAA,CAAQI,OAAA,CAAQhF,IAAA,KAEhB6E,EAAA,CAAWG,OAAA,CAAQrQ,CAAA,MAGrB8P,CAAA,CAASO,OAAA,KAAa,IAAIvP,IAAA,KAAU+O,CAAA,CAASQ,OAAA,EAC7CI,EAAA,IACIR,EAAA,CAAQI,OAAA,GAEVJ,EAAA,CAAQI,OAAA,CAAQ5E,MAAA,KAEhB0E,EAAA,CAAaE,OAAA,CAAQrQ,CAAA;IAAA;IASrB0Q,EAAA,GAAe,SAAA9C,CAAA5N,CAAA;MAAA,IAEnBsQ,EAAA,CAAqBtQ,CAAA,IAGjBgM,CAAA,CAAUqE,OAAA;QAAA,IAIC,gBAAXrQ,CAAA,CAAEwC,IAAA,EAAsB;UAAA,IAEtBxC,CAAA,CAAEiN,KAAA,KAAUP,CAAA,IAAS1M,CAAA,CAAEkN,KAAA,KAAUwC,CAAA;UAAA,SAId,MAAZ1P,CAAA,CAAEiN,KAAA,SAA4C,MAAZjN,CAAA,CAAEkN,KAAA;UAAA,IAK/ByD,EAAA,KACF;QAAA;QAMhBlQ,YAAA,CAAakP,CAAA,CAAIU,OAAA,GACjBV,CAAA,CAAIU,OAAA,GAAU;QAAA,IAGRpQ,CAAA,IAA8B,IAAIa,IAAA,KAAS8P,EAAA;QAAA,CAI9C7I,CAAA,CAAKsI,OAAA,KAAYrK,CAAA,KAChB+B,CAAA,CAAKsI,OAAA,IAAWpQ,CAAA,GAA6B+P,CAAA,CAASK,OAAA,KAExDE,EAAA,CAAiBvQ,CAAA,GAKnB4P,CAAA,CAAWS,OAAA,IAAW,IAAIvP,IAAA,IAC1B4L,CAAA,CAAM2D,OAAA,GAAUrQ,CAAA,CAAEiN,KAAA,EAClByC,CAAA,CAAMW,OAAA,GAAUrQ,CAAA,CAAEkN,KAAA,EAGbnF,CAAA,CAAKsI,OAAA,KACRV,CAAA,CAAIU,OAAA,GAAU3P,UAAA,CAAW6P,EAAA,EAAkBP,CAAA,CAASK,OAAA;MAAA;IAAA;IAQlDQ,EAAA,GAAcrG,CAAA,CAAOkG,EAAA;IAMrBD,EAAA,GAAc,SAAA/B,CAAA;MAGbjP,CAAA,KAGA6H,CAAA,CAAY+I,OAAA,KACfnL,CAAA,CAAOa,OAAA,CAAQ,UAAA/F,CAAA;QACbM,CAAA,CAAQ6D,gBAAA,CAAiBnE,CAAA,EAAG6Q,EAAA,CAAYR,OAAA,EAAS;UAC/Cf,OAAA,EAAAjJ,CAAA;UACAgJ,OAAA,EAAApI;QAAA;MAAA,IAGJK,CAAA,CAAY+I,OAAA,IAAU;IAAA;IAQpBG,EAAA,GAAgB,SAAA7B,CAAA;MAAA,IAAC3O,CAAA,GAAAI,SAAA,CAAAC,MAAA,mBAAAD,SAAA,OAAAA,SAAA;MAGhBX,CAAA,KAED6H,CAAA,CAAY+I,OAAA,IAAWrQ,CAAA,MACzBkF,CAAA,CAAOa,OAAA,CAAQ,UAAA/F,CAAA;QACbM,CAAA,CAAQ0E,mBAAA,CAAoBhF,CAAA,EAAG6Q,EAAA,CAAYR,OAAA,EAAS;UAClDf,OAAA,EAAAjJ,CAAA;UACAgJ,OAAA,EAAApI;QAAA;MAAA,IAGJK,CAAA,CAAY+I,OAAA,IAAU;IAAA;IASpBS,EAAA,GAAmB,SAAA5C,CAAA;MAAA,IAEG,SAAtBlC,CAAA,CAAUqE,OAAA,SACLrE,CAAA,CAAUqE,OAAA,GAAU,IAAI,IAAIrE,CAAA,CAAUqE,OAAA;MAAA,IAIzCrQ,CAAA,GAAWgQ,CAAA,CAASK,OAAA,KAAa,IAAIvP,IAAA,KAAU8O,CAAA,CAAWS,OAAA;MAAA,OACzDrQ,CAAA,GAAW,IAAI,IAAIA,CAAA;IAAA;IAQtB2Q,EAAA,GAAiB,SAAAxC,CAAA;MAAA,QAAQ,IAAIrN,IAAA,KAAU0I,CAAA,CAAQ6G,OAAA;IAAA;IAO/CU,EAAA,GAAkB,SAAA1C,CAAA;MAAA,OAAMwB,CAAA,CAASQ,OAAA;IAAA;IAOjCW,EAAA,GAAmB,SAAA1C,CAAA;MAAA,OACnBvG,CAAA,CAAKsI,OAAA,IACG,IAAIvP,IAAA,KAAU+O,CAAA,CAASQ,OAAA,GAAWP,CAAA,CAASO,OAAA,GAE9CP,CAAA,CAASO,OAAA;IAAA;IASdO,EAAA,GAAoB,SAAAxC,CAAA;MAAA,OAAMwB,CAAA,CAAWS,OAAA;IAAA;IAOrCY,EAAA,GAAqB,SAAA1C,CAAA;MAAA,OAAMoC,EAAA,KAAmBK,EAAA;IAAA;IAO9CE,EAAA,GAAS,SAAAjD,CAAA;MAAA,OAAMlG,CAAA,CAAKsI,OAAA;IAAA;IAMpBc,EAAA,GAAW,SAAAjJ,CAAA;MAAA,QAAM+H,EAAA,CAAQI,OAAA,IAAUJ,EAAA,CAAQI,OAAA,CAAQnI,QAAA;IAAA;IAMnDkJ,EAAA,GAAQ,SAAA3G,CAAA;MAAA,IAACzK,CAAA,GAAAI,SAAA,CAAAC,MAAA,mBAAAD,SAAA,OAAAA,SAAA;MAEbK,YAAA,CAAakP,CAAA,CAAIU,OAAA,GACjBV,CAAA,CAAIU,OAAA,GAAU,MAGdI,EAAA,IAGA1I,CAAA,CAAKsI,OAAA,IAAU,GACf7G,CAAA,CAAQ6G,OAAA,IAAW,IAAIvP,IAAA,IACvB8O,CAAA,CAAWS,OAAA,IAAW,IAAIvP,IAAA,IAC1BkL,CAAA,CAAUqE,OAAA,GAAU,MAEhBJ,EAAA,CAAQI,OAAA,KAEVJ,EAAA,CAAQI,OAAA,CAAQtE,UAAA,EAAW,KAEtB/L,CAAA,IAAUuH,CAAA,CAAS+C,aAAA,IACtB2F,EAAA,CAAQI,OAAA,CAAQxE,IAAA,CAAK,WAKzB8D,CAAA,CAAIU,OAAA,GAAU3P,UAAA,CAAW6P,EAAA,EAAkBP,CAAA,CAASK,OAAA;IAAA;IAOhDgB,EAAA,GAAQ,SAAA1G,CAAA;MAAA,IAAC3K,CAAA,GAAAI,SAAA,CAAAC,MAAA,mBAAAD,SAAA,OAAAA,SAAA;MAEbK,YAAA,CAAakP,CAAA,CAAIU,OAAA,GACjBV,CAAA,CAAIU,OAAA,GAAU,MAGdI,EAAA,IAGI1I,CAAA,CAAKsI,OAAA,KACHJ,EAAA,CAAQI,OAAA,GAEVJ,EAAA,CAAQI,OAAA,CAAQ5E,MAAA,KAEhB0E,EAAA,CAAaE,OAAA,KAKjBtI,CAAA,CAAKsI,OAAA,IAAU,GACf7G,CAAA,CAAQ6G,OAAA,IAAW,IAAIvP,IAAA,IACvB8O,CAAA,CAAWS,OAAA,IAAW,IAAIvP,IAAA,IAC1BkL,CAAA,CAAUqE,OAAA,GAAU,MAEhBJ,EAAA,CAAQI,OAAA,KAEVJ,EAAA,CAAQI,OAAA,CAAQtE,UAAA,EAAW,KAEtB/L,CAAA,IAAUuH,CAAA,CAAS+C,aAAA,IACtB2F,EAAA,CAAQI,OAAA,CAAQxE,IAAA,CAAK,WAKzB8D,CAAA,CAAIU,OAAA,GAAU3P,UAAA,CAAW6P,EAAA,EAAkBP,CAAA,CAASK,OAAA;IAAA;IAOhDiB,EAAA,GAAQ,SAAAzG,CAAA;MAAA,IAAC7K,CAAA,GAAAI,SAAA,CAAAC,MAAA,mBAAAD,SAAA,OAAAA,SAAA;MAEa,SAAtB4L,CAAA,CAAUqE,OAAA,KAGdG,EAAA,IAGA/P,YAAA,CAAakP,CAAA,CAAIU,OAAA,GACjBV,CAAA,CAAIU,OAAA,GAAU,MAGdrE,CAAA,CAAUqE,OAAA,GAAUS,EAAA,IAEhBb,EAAA,CAAQI,OAAA,KAELrQ,CAAA,IAAUuH,CAAA,CAAS+C,aAAA,IACtB2F,EAAA,CAAQI,OAAA,CAAQxE,IAAA,CAAK;IAAA;IASrB0F,EAAA,GAAS,SAAAxG,CAAA;MAAA,IAAC/K,CAAA,GAAAI,SAAA,CAAAC,MAAA,mBAAAD,SAAA,OAAAA,SAAA;MAEY,SAAtB4L,CAAA,CAAUqE,OAAA,KAGdI,EAAA,IAIK1I,CAAA,CAAKsI,OAAA,KAERV,CAAA,CAAIU,OAAA,GAAU3P,UAAA,CAAW6P,EAAA,EAAkBvE,CAAA,CAAUqE,OAAA,GAErDrE,CAAA,CAAUqE,OAAA,GAAU,MACpBT,CAAA,CAAWS,OAAA,IAAW,IAAIvP,IAAA,KAGxBmP,EAAA,CAAQI,OAAA,KAELrQ,CAAA,IAAUuH,CAAA,CAAS+C,aAAA,IACtB2F,EAAA,CAAQI,OAAA,CAAQxE,IAAA,CAAK;IAAA;EAAA,OAQ3BnB,CAAA,CAAU;IAAA,IAEJlJ,CAAA,GAAW,KAAKG,CAAA,GAAW,SACvB,IAAI6C,KAAA,CAAM;IAAA,OAKd+C,CAAA,KACF0I,EAAA,CAAQI,OAAA,GAAUjG,CAAA,CAAW;MAC3B5H,IAAA,EAAM+E,CAAA,CAAS/E,IAAA;MACfkC,WAAA,EAAa6C,CAAA,CAAS7C,WAAA;MACtBsF,gBAAA,EAAkBzC,CAAA,CAASyC,gBAAA;MAC3BP,YAAA,EAAclC,CAAA,CAASkC,YAAA;MACvBa,aAAA,EAAe/C,CAAA,CAAS+C,aAAA;MACxBC,SAAA,EAAW;QACTY,MAAA,EAAQ+E,EAAA,CAAWG,OAAA;QACnBjF,QAAA,EAAU+E,EAAA,CAAaE;MAAA;MAEzB5F,KAAA,EAAA2G,EAAA;MACAzG,KAAA,EAAA0G,EAAA;MACAxG,KAAA,EAAAyG,EAAA;MACAvG,MAAA,EAAAwG;IAAA,KAKA7L,CAAA,GAAAkD,CAAA,CAAAC,CAAA,CAAAC,IAAA,CACK,SAAA9I,EAAA;MAAA,OAAA6I,CAAA,CAAAE,IAAA,WAAA/I,CAAA;QAAA,iBAAAA,CAAA,CAAAgJ,IAAA,GAAAhJ,CAAA,CAAAyD,IAAA;UAAA;YAAA,IACLhD,YAAA,CAAakP,CAAA,CAAIU,OAAA,GACjBG,EAAA,EAAc,KACVjJ,CAAA;cAAAvH,CAAA,CAAAyD,IAAA;cAAA;YAAA;YAAA,OAAAzD,CAAA,CAAAyD,IAAA,MAAgBwM,EAAA,CAAQI,OAAA,CAAQnO,KAAA;UAAA;UAAA;YAAA,OAAAlC,CAAA,CAAAiJ,IAAA;QAAA;MAAA,GAAAjJ,CAAA;IAAA,OAIpCoE,CAAA,GACFgN,EAAA,KAEAX,EAAA,IAAA7H,CAAA,CAAAC,CAAA,CAAAC,IAAA,CAIK,SAAA9I,EAAA;MAAA,OAAA6I,CAAA,CAAAE,IAAA,WAAA/I,CAAA;QAAA,iBAAAA,CAAA,CAAAgJ,IAAA,GAAAhJ,CAAA,CAAAyD,IAAA;UAAA;YAAA,IACLhD,YAAA,CAAakP,CAAA,CAAIU,OAAA,GACjBG,EAAA,EAAc,IACVF,EAAA,CAAqB1P,MAAA,IAAQ0P,EAAA,CAAqB1P,MAAA,KAClD2G,CAAA;cAAAvH,CAAA,CAAAyD,IAAA;cAAA;YAAA;YAAA,OAAAzD,CAAA,CAAAyD,IAAA,MAAgBwM,EAAA,CAAQI,OAAA,CAAQnO,KAAA;UAAA;UAAA;YAAA,OAAAlC,CAAA,CAAAiJ,IAAA;QAAA;MAAA,GAAAjJ,CAAA;IAAA;EAAA,GAErC,KAEH0K,CAAA,CAAU;IAAA,IACF1K,CAAA,GAAkBsH,CAAA,CAAY+I,OAAA;IAChCrQ,CAAA,IAAiBwQ,EAAA,IAEnBK,EAAA,CAAYR,OAAA,GADVzM,CAAA,GAAiB,IACG/C,CAAA,CAAU6P,EAAA,EAAc9M,CAAA,IAExB8M,EAAA,EAEpB1Q,CAAA,IAAiByQ,EAAA;EAAA,GACpB,CAAC7M,CAAA,IAEJ8G,CAAA,CAAU;IACRsF,CAAA,CAASK,OAAA,GAAUnQ,CAAA,GACd6P,CAAA,CAAUM,OAAA,IAAWtI,CAAA,CAAKsI,OAAA,IAC7BgB,EAAA,IAEFtB,CAAA,CAAUM,OAAA,IAAU;EAAA,GACnB,CAACnQ,CAAA,IAEG;IACL+N,MAAA,EAAAiD,EAAA;IACAhJ,QAAA,EAAAiJ,EAAA;IACA1G,KAAA,EAAA2G,EAAA;IACAvG,KAAA,EAAAyG,EAAA;IACA3G,KAAA,EAAA0G,EAAA;IACAtG,MAAA,EAAAwG,EAAA;IACAlD,eAAA,EAAA0C,EAAA;IACAzC,gBAAA,EAAA0C,EAAA;IACA5C,iBAAA,EAAAwC,EAAA;IACArC,kBAAA,EAAA0C,EAAA;IACA9C,cAAA,EAAAwC,EAAA;IACAzC,gBAAA,EAAA4C;EAAA;AAAA;ADiGJpE,CAAA,CAAU8E,SAAA,GAAY;EAMpB5C,OAAA,EAAS9D,CAAA,CAAU2G,MAAA;EAMnBrC,MAAA,EAAQtE,CAAA,CAAU4G,OAAA,CAAQ5G,CAAA,CAAU6G,MAAA;EAMpCxG,MAAA,EAAQL,CAAA,CAAU8G,IAAA;EAMlBxG,QAAA,EAAUN,CAAA,CAAU8G,IAAA;EAMpBnE,QAAA,EAAU3C,CAAA,CAAU8G,IAAA;EAMpBtE,QAAA,EAAUxC,CAAA,CAAU2G,MAAA;EAMpBlE,QAAA,EAAUzC,CAAA,CAAU2G,MAAA;EAMpB/D,cAAA,EAAgB5C,CAAA,CAAU2G,MAAA;EAM1BtC,OAAA,EAASrE,CAAA,CAAU+G,SAAA,CAAU,CAAC/G,CAAA,CAAUgH,MAAA,EAAQhH,CAAA,CAAUqE,OAAA;EAM1DrB,YAAA,EAAchD,CAAA,CAAUiH,IAAA;EAMxBhE,aAAA,EAAejD,CAAA,CAAUiH,IAAA;EAQzBvC,UAAA,EAAY1E,CAAA,CAAUiH,IAAA;EAMtB1C,OAAA,EAASvE,CAAA,CAAUiH,IAAA;EAMnBzC,OAAA,EAASxE,CAAA,CAAUiH,IAAA;EAMnB9C,QAAA,EAAUnE,CAAA,CAAU+G,SAAA,CAAU,CAC5B/G,CAAA,CAAUiH,IAAA,EACVjH,CAAA,CAAUkH,KAAA,CAAM;IACdxP,IAAA,EAAMsI,CAAA,CAAUmH,KAAA,CAAM,CAAC,oBAAoB,gBAAgB;IAC3DvN,WAAA,EAAaoG,CAAA,CAAU6G,MAAA;IACvB3H,gBAAA,EAAkBc,CAAA,CAAU2G,MAAA;IAC5BhI,YAAA,EAAcqB,CAAA,CAAU2G,MAAA;IACxBhN,aAAA,EAAeqG,CAAA,CAAU2G,MAAA;IACzBnH,aAAA,EAAeQ,CAAA,CAAUiH;EAAA;AAAA,GAU/BrF,CAAA,CAAUwF,YAAA,GAAe;EACvBtD,OAAA,EAAS;EACTO,OAAA,EAASvP,CAAA;EACTwP,MAAA,EAAQtP,CAAA;EACRqL,MAAA,EAAQ,SAAAA,CAAA;EACRC,QAAA,EAAU,SAAAA,CAAA;EACVqC,QAAA,EAAU,SAAAA,CAAA;EACVH,QAAA,EAAU;EACVC,QAAA,EAAU;EACVG,cAAA,EAAgB;EAChBI,YAAA,GAAc;EACdC,aAAA,GAAe;EACfyB,UAAA,GAAY;EACZF,OAAA,GAAS;EACTD,OAAA,GAAS;EACTJ,QAAA,GAAU;AAAA,GCrNZS,CAAA,CAAa8B,SAAA,GAAY;EAMvB5C,OAAA,EAAS9D,CAAA,CAAU2G,MAAA;EAMnBrC,MAAA,EAAQtE,CAAA,CAAU4G,OAAA,CAAQ5G,CAAA,CAAU6G,MAAA;EAMpCxG,MAAA,EAAQL,CAAA,CAAU8G,IAAA;EAMlBxG,QAAA,EAAUN,CAAA,CAAU8G,IAAA;EAMpBnE,QAAA,EAAU3C,CAAA,CAAU8G,IAAA;EAMpBtE,QAAA,EAAUxC,CAAA,CAAU2G,MAAA;EAMpBlE,QAAA,EAAUzC,CAAA,CAAU2G,MAAA;EAMpB/D,cAAA,EAAgB5C,CAAA,CAAU2G,MAAA;EAM1BtC,OAAA,EAASrE,CAAA,CAAU+G,SAAA,CAAU,CAAC/G,CAAA,CAAUgH,MAAA,EAAQhH,CAAA,CAAUqE,OAAA;EAM1DrB,YAAA,EAAchD,CAAA,CAAUiH,IAAA;EAMxBhE,aAAA,EAAejD,CAAA,CAAUiH,IAAA;EAQzBvC,UAAA,EAAY1E,CAAA,CAAUiH,IAAA;EAMtB1C,OAAA,EAASvE,CAAA,CAAUiH,IAAA;EAMnBzC,OAAA,EAASxE,CAAA,CAAUiH,IAAA;EAMnB9C,QAAA,EAAUnE,CAAA,CAAU+G,SAAA,CAAU,CAC5B/G,CAAA,CAAUiH,IAAA,EACVjH,CAAA,CAAUkH,KAAA,CAAM;IACdxP,IAAA,EAAMsI,CAAA,CAAUmH,KAAA,CAAM,CAAC,oBAAoB,gBAAgB;IAC3DvN,WAAA,EAAaoG,CAAA,CAAU6G,MAAA;IACvB3H,gBAAA,EAAkBc,CAAA,CAAU2G,MAAA;IAC5BhI,YAAA,EAAcqB,CAAA,CAAU2G,MAAA;IACxBhN,aAAA,EAAeqG,CAAA,CAAU2G,MAAA;IACzBnH,aAAA,EAAeQ,CAAA,CAAUiH;EAAA;AAAA,GAU/BrC,CAAA,CAAawC,YAAA,GAAe;EAC1BtD,OAAA,EAAS;EACTO,OAAA,EAASvP,CAAA;EACTwP,MAAA,EAAQtP,CAAA;EACRqL,MAAA,EAAQ,SAAAA,CAAA;EACRC,QAAA,EAAU,SAAAA,CAAA;EACVqC,QAAA,EAAU,SAAAA,CAAA;EACVH,QAAA,EAAU;EACVC,QAAA,EAAU;EACVG,cAAA,EAAgB;EAChBI,YAAA,GAAc;EACdC,aAAA,GAAe;EACfyB,UAAA,GAAY;EACZF,OAAA,GAAS;EACTD,OAAA,GAAS;EACTJ,QAAA,GAAU;AAAA;AAAA,eAAAvC,CAAA;AAAA,SAAAgD,CAAA,IAAAyC,YAAA"},"metadata":{},"sourceType":"module"}